<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Threading</name>
    </assembly>
    <members>
        <member name="T:System.Threading.Internal.Platform">
            <summary>
            A convenience class for common platform-related logic.
            </summary>
        </member>
        <member name="M:System.Threading.Internal.Platform.Yield">
            <summary>
            Yields the current thread's timeslice.
            </summary>
        </member>
        <member name="P:System.Threading.Internal.Platform.ProcessorCount">
            <summary>
            Gets the number of available processors available to this process on the current machine.
            </summary>
        </member>
        <member name="P:System.Threading.Internal.Platform.IsSingleProcessor">
            <summary>
            Gets whether the current machine has only a single processor.
            </summary>
        </member>
        <member name="T:System.Threading.AggregateException">
            <summary>Represents multiple errors that occur during application execution.</summary>
            <remarks>
            <see cref="T:System.Threading.AggregateException"/> is used to consolidate multiple failures into a
            single, throwable exception object, for cases where multiple exceptions may happen in parallel.
            While <see cref="T:System.Threading.AggregateException"/> may be instantiated by user code, the need
            to do so is rare, as instances of <see cref="T:System.Threading.AggregateException"/> are generated
            internally by the system.
            </remarks>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class.
            </summary>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            a specified error message and a reference to the inner exception that is the cause of this
            exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">The exception that is the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="inner"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.Exception[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            a specified error message and references to the inner exceptions that are the cause of this
            exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.String,System.Exception[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            a specified error message and references to the inner exceptions that are the cause of this
            exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.String,System.Collections.Generic.IList{System.Exception})">
            <summary>
            Allocates a new aggregate exception with the specified message and list of inner exceptions.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.AggregateException"/> class with
            serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.AggregateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.AggregateException.Handle(System.Func{System.Exception,System.Boolean})">
            <summary>
            Invokes a handler on each <see cref="T:System.Exception"/> contained by this <see cref="T:System.Threading.AggregateException"/>.
            </summary>
            <param name="handler">The handler to execute for each exception. The handler accepts as an
            argument the <see cref="T:System.Exception"/> to be processed and returns a Boolean to indicate
            whether the exception was handled.</param>
            <remarks>
            Each invocation of the <paramref name="handler"/> returns true or false to indicate whether the
            <see cref="T:System.Exception"/> was handled. After all invocations, if any exceptions went unhandled, all
            unhandled exceptions will be put into a new <see cref="T:System.Threading.AggregateException"/>
            which will be thrown. Otherwise, the <see cref="M:System.Threading.AggregateException.Handle(System.Func{System.Exception,System.Boolean})"/> method simply returns. If any
            invocations of the <paramref name="handler"/> throws an exception, it will halt the processing of
            any more exceptions and immediately propagate the thrown exception as-is.
            </remarks>
            <exception cref="T:System.Threading.AggregateException">An exception contained by this <see cref="T:System.Threading.AggregateException"/> was not handled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="handler"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.AggregateException.Flatten">
            <summary>
            Flattens many <see cref="T:System.Threading.AggregateException"/> instances into a single,
            new instance.  If any inner exceptions are themselves instances of 
            <see cref="T:System.Threading.AggregateException"/>, this method will recursively flatten 
            all of them.
            </summary>
            <returns>A new, flattened <see cref="T:System.Threading.AggregateException"/>.</returns>
            <remarks>
            The inner exceptions returned in the new <see cref="T:System.Threading.AggregateException"/>
            will be the union of all of the the inner exceptions from exception tree rooted at the provided
            <see cref="T:System.Threading.AggregateException"/> instance.
            </remarks>
        </member>
        <member name="M:System.Threading.AggregateException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>A string representation of the current exception.</returns>
        </member>
        <member name="P:System.Threading.AggregateException.InnerExceptions">
            <summary>
            Gets a read-only collection of the <see cref="T:System.Exception"/> instances that caused the
            current exception.
            </summary>
        </member>
        <member name="T:System.Threading.Collections.BlockingCollection`1">
            <summary>
            Provides blocking and bounding capabilities for thread-safe collections that 
            implement <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>. 
            </summary>
            <remarks>
            <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/> represents a collection
            that allows for thread-safe adding and removing of data. 
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> is used as a wrapper
            for an <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/> instance, allowing
            removal attempts from the collection to block until data is available to be removed.  Similarly,
            a <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> can be created to enforce
            an upper-bound on the number of data elements allowed in the 
            <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>; addition attempts to the
            collection may then block until space is available to store the added items.  In this manner,
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> is similar to a traditional
            blocking queue data structure, except that the underlying data storage mechanism is abstracted
            away as an <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>. 
            </remarks>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>
            class without an upper-bound.
            </summary>
            <remarks>
            The default underlying collection is a <see cref="T:System.Threading.Collections.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>
            class with the specified upper-bound.
            </summary>
            <param name="boundedCapacity">The bounded size of the collection.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity"/> is
            not a positive value.</exception>
            <remarks>
            The default underlying collection is a <see cref="T:System.Threading.Collections.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.#ctor(System.Threading.Collections.IConcurrentCollection{`0},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>
            class with the specified upper-bound and using the provided 
            <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/> as its underlying data store.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <param name="boundedCapacity">The bounded size of the collection.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity"/> is not a positive value.</exception>
            <exception cref="T:System.ArgumentException">The supplied <paramref name="collection"/> contains more values 
            than is permitted by <paramref name="boundedCapacity"/>.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.#ctor(System.Threading.Collections.IConcurrentCollection{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>
            class without an upper-bound and using the provided 
            <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/> as its underlying data store.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.Initialize(System.Threading.Collections.IConcurrentCollection{`0},System.Int32)">
            <summary>Initializes the BlockingCollection instance.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <param name="boundedCapacity">The bounded size of the collection.</param>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.Add(`0)">
            <summary>
            Adds the item to the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection. The value can be a null reference.</param>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <remarks>
            If a bounded capacity was specified when this instance of 
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> was initialized, 
            a call to <see cref="M:System.Threading.Collections.BlockingCollection`1.Add(`0)"/> may block until space is available to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAdd(`0)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <returns>true if the <paramref name="item"/> could be added; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <paramref name="item"/> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the <paramref name="item"/> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAddWithNoTimeValidation(`0,System.Int32)">
            <summary>Adds an item into the underlying data store using its IConcurrentCollection&lt;T&gt;.Add 
            method. If a bounded capacity was specified and the collection was full, 
            this method will wait for, at most, the timeout period trying to add the item. 
            If the timeout period was exhaused before successfully adding the item this method will 
            return false.</summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to accept the item,
            or Timeout.Infinite to wait indefinitely.</param>
            <returns>False if the collection remained full till the timeout period was exhausted.True otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">the collection has already been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.ValidateTimeout(System.TimeSpan)">
            <summary>Centeralizes the logic of validating the timeout input argument.</summary>
            <param name="timeout">The TimeSpan to wait for to successfully complete an operation on the collection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the number of millseconds represented by the timeout 
            TimeSpan is less than 0 or is larger than Int32.MaxValue and not Timeout.Infinite</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.ValidateMillisecondsTimeout(System.Int32)">
            <summary>Centralizes the logic of validating the millisecondsTimeout input argument.</summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait for to successfully complete an 
            operation on the collection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the number of millseconds is less than 0 and not 
            equal to Timeout.Infinite.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.Remove">
            <summary>Removes an item from the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.</summary>
            <returns>The item removed from the collection.</returns>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> is empty and has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Threading.Collections.BlockingCollection`1.Remove"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemove(`0@)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <returns>true if an item could be removed; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemove(`0@,System.TimeSpan)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemove(`0@,System.Int32)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemoveWithNoTimeValidation(`0@,System.Int32)">
            <summary>Removes an item from the underlying data store using its IConcurrentCollection&lt;T&gt;.Remove 
            method. If the collection was empty, this method will wait for, at most, the timeout period (if AddingIsCompleted is false)
            trying to remove an item. If the timeout period was exhaused before successfully removing an item 
            this method will return false.</summary>
            <param name="item">The item removed from the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to have an item available 
            for removal, or Timeout.Infinite to wait indefinitely.</param>
            <returns>False if the collection remained empty till the timeout period was exhausted. True otherwise.</returns>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.ReleaseSemaphore(System.Threading.SemaphoreSlim)">
            <summary>This method will be used whenever it's desired to release a semaphore. This is because if the 
            semaphore being released was canceled, this semaphore will throw an OperationCanceledException which 
            is not of real use for purposes of BlockingCollection.</summary>
            <param name="semaphore">The semaphore being released</param>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.AddAny(System.Threading.Collections.BlockingCollection{`0}[],`0)">
            <summary>
            Adds the specified item to any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array to which the item was added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <remarks>
            If a bounded capacity was specified when all of the
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances were initialized, 
            a call to <see cref="M:System.Threading.Collections.BlockingCollection`1.AddAny(System.Threading.Collections.BlockingCollection{`0}[],`0)"/> may block until space is available in one of the collections
            to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAddAny(System.Threading.Collections.BlockingCollection{`0}[],`0)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAddAny(System.Threading.Collections.BlockingCollection{`0}[],`0,System.TimeSpan)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAddAny(System.Threading.Collections.BlockingCollection{`0}[],`0,System.Int32)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>        /// <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryAddRemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.Collections.BlockingCollection{`0}.OperationMode)">
            <summary>Adds/Removes an item to/from anyone of the specified collections.</summary>
            <param name="collections">The collections into which the item can be added.</param>
            <param name="item">The item to be added or the item removed and returned to the caller.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for a collection to accept the 
            operation, or -1 to wait indefinitely.</param>
            <param name="operationMode">Indicates whether this method is called to Add or Remove.</param>
            <returns>The index into collections for the collection which accepted the 
            adding/removal of the item; -1 if the item could not be added/removed.</returns>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if atleast one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If atleast one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.ValidateCollectionsArray(System.Threading.Collections.BlockingCollection{`0}[],System.Threading.Collections.BlockingCollection{`0}.OperationMode)">
            <summary>Centralizes the logic for validating the BlockingCollections array passed to TryAddAny()
            and TryRemoveAny().</summary>
            <param name="collections">The collections to/from which an item should be added/removed.</param>
            <param name="operationMode">Indicates whether this method is called to Add or Remove.</param>
            <returns>A copy of the collections array that acts as a defense to prevent an “outsider” from changing 
            elements of the array after we have done the validation on them.</returns>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if atleast one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If atleast one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.RemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)">
            <summary>
            Removes an item from any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Threading.Collections.BlockingCollection`1.RemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Threading.Collections.BlockingCollection`1.RemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@,System.TimeSpan)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Threading.Collections.BlockingCollection`1.RemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.TryRemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@,System.Int32)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Threading.Collections.BlockingCollection`1.RemoveAny(System.Threading.Collections.BlockingCollection{`0}[],`0@)"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.CompleteAdding">
            <summary>
            Marks the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instances
            as not accepting any more additions.  
            </summary>
            <remarks>
            After a collection has been marked as complete for adding, adding to the collection is not permitted 
            and attempts to remove from the collection will not wait when the collection is empty.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The collection has already been marked as complete for adding.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.CancelSemaphores">
            <summary>Cancels the semaphores.</summary>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.CheckAddingIsCompleted">
            <summary>Throws a System.OperationCanceledException exception if the collection was in an interrupted state.</summary>
            <exception cref="T:System.InvalidOperationException">If the collection has been marked as complete for adds.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.CheckAddingIsCompleted(System.String)">
            <summary>Throws a System.OperationCanceledException exception if the collection was in an interrupted state.</summary>
            <param name="exceptionMsg">The message to be added in the exception.</param>
            <exception cref="T:System.InvalidOperationException">If the collection has been marked as complete for adds.</exception>        
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.Dispose">
            <summary>Releases resources used by the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</summary>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.CheckDisposed">
            <summary>Throws a System.ObjectDisposedException if the collection was disposed</summary>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.ToArray">
            <summary>Copies the items from the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance into a new array.</summary>
            <returns>An array containing copies of the elements of the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
            <remarks>
            The copied elements are not removed from the collection.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.BlockingCollection`1.CopyTo(`0[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" -->
        <member name="M:System.Threading.Collections.BlockingCollection`1.GetConsumingEnumerable">
            <summary>Provides a consuming <see cref="T:System.Collections.Generics.IEnumerable{T}"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerable{T}"/> that removes and returns items from the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for the items in the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Collections.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.IEnumerator"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the items in the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.BoundedCapacity">
            <summary>Gets the bounded capacity of this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> instance.</summary>
            <value>The bounded capacity of this collection, or int.MaxValue if no bound was supplied.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.IsAddingCompleted">
            <summary>Gets whether this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked as complete for adding.</summary>
            <value>Whether this collection has been marked as complete for adding.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.IsCompleted">
            <summary>Gets whether this <see cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been marked as complete for adding and is empty.</summary>
            <value>Whether this collection has been marked as complete for adding and is empty.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.Count">
            <summary>Gets the number of items contained in the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.</summary>
            <value>The number of items contained in the <see cref="T:System.Threading.Collections.BlockingCollection{T}"/>.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized.</summary>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Collections.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.</summary>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Collections.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="T:System.Threading.Collections.BlockingCollection`1.OperationMode">
            <summary>An enumerated data type used internal to the class to specify to a generic method
            the current mode of operation.</summary>
        </member>
        <member name="T:System.Threading.Collections.SystemThreadingCollections_BlockingCollectionDebugView`1">
            <summary>A debugger view of the blocking collection that makes it simple to browse the
            collection's contents at a point in time.</summary>
            <typeparam name="T">The type of element that the BlockingCollection will hold.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.SystemThreadingCollections_BlockingCollectionDebugView`1.#ctor(System.Threading.Collections.BlockingCollection{`0})">
            <summary>Constructs a new debugger view object for the provided blocking collection object.</summary>
            <param name="collection">A blocking collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.Collections.SystemThreadingCollections_BlockingCollectionDebugView`1.Items">
            <summary>Returns a snapshot of the underlying collection's elements.</summary>
        </member>
        <member name="T:System.Threading.Collections.ConcurrentQueue`1">
            <summary>
            Represents a thread-safe first-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
        </member>
        <member name="T:System.Threading.Collections.IConcurrentCollection`1">
            <summary>
            A common interface for all concurrent collections, providing basic thread-safe operations.
            </summary>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.IConcurrentCollection`1.Add(`0)">
            <summary>
            Adds an object to the <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>.
            </summary>
            <param name="element">The object to add to the <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>.</param>
            <returns>True if an element was successfully added; otherwise, false.</returns>
            <remarks>
            If the object was successfully added, incrementing the number of elements in the collection by
            one, <see cref="M:System.Threading.Collections.IConcurrentCollection`1.Add(`0)"/> returns true. If the object was not added, leaving the number of elements
            in the collection unmodified, <see cref="M:System.Threading.Collections.IConcurrentCollection`1.Add(`0)"/> returns false.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.IConcurrentCollection`1.Remove(`0@)">
            <summary>
            Removes and returns an object from the <see cref="T:System.Threading.Collections.IConcurrentCollection{T}"/>. The return value indicates whether an
            object was successfully removed.
            </summary>
            <param name="result">
            When this method returns, if the removal succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
            <remarks>
            If an object was successfully removed, decrementing the number of elements in the collection by
            one, <see cref="M:System.Threading.Collections.IConcurrentCollection`1.Remove(`0@)"/> returns true. If an object was not removed, leaving the number of elements
            in the collection unmodified, <see cref="M:System.Threading.Collections.IConcurrentCollection`1.Remove(`0@)"/> returns false.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.IConcurrentCollection`1.ToArray">
            <summary>Copies the items from the <see
            cref="T:System.Threading.Collections.IConcurrentCollection{T}"/> instance into a new array.</summary>
            <returns>An array containing copies of the elements of the collection.</returns>
            <remarks>
            The returned elements should mirror what a call to GetEnumerator would return at an instant in
            time. If the collection is empty, an empty array will be returned.
            </remarks>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>
            class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" -->
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>
            class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the collection.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the contents of the queue from an existing collection.
            </summary>
            <param name="collection">A collection from which to copy elements.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentQueue`1.CopyTo(`0[],System.Int32)" -->
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about
            the collection.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the collection.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.OnDeserialization(System.Object)">
            <summary>
            Implements the <see cref="T:System.ISerializable"/> interface and is called back by the
            deserialization event when deserialization is complete.
            </summary>
            <param name="sender">The source of the deserialization event.</param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.GetTailAndCatchUp">
            <summary>
            Retrieves the most current tail pointer. If the tail has fallen behind,
            we will catch it up by CASing it until we see a null next node.
            </summary>
            <param name="tail">The tail seen by a caller.</param>
            <returns>The most recent tail seen by this function.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.Enqueue(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>.
            </summary>
            <param name="element">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>. The value can be null for reference
            types.
            </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.EnqueueCore(System.Threading.Collections.ConcurrentQueue{`0}.Node)">
            <summary>
            Slow path helper for Enqueue.  Assumes an initial attempt to enqueue an element has
            been made and failed, and will begin spinning right away.
            </summary>
            <param name="element">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>. The value can be null for reference
            types.
            </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.System#Threading#Collections#IConcurrentCollection{T}#Add(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>.
            </summary>
            <param name="element">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>. The value can be null for reference
            types.
            </param>
            <returns>True if an element was successfully added; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Removes and returns the object at the beginning of the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>. The return value indicates whether an
            object was successfully removed.
            </summary>
            <param name="result">
            When this method returns, if the dequeue suceeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.TryDequeueCore(`0@)">
            <summary>
            Slow path helper for TryDequeue.  This assumes an initial attempt to dequeue has
            already been made and failed, so it spins right away.
            </summary>
            <param name="result">
            When this method returns, if the dequeue suceeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.System#Threading#Collections#IConcurrentCollection{T}#Remove(`0@)">
            <summary>
            Removes and returns the object at the beginning of the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>. The return value indicates whether an
            object was successfully removed.
            </summary>
            <param name="result">
            When this method returns, if the dequeue successed, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Returns the object at the beginning of the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/> without removing it.
            </summary>
            <param name="result">
            When this method returns, if the peek successed, contains the object. If no object was available,
            the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was available; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.ToArray">
            <summary>Copies the items from the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/> instance into a new array.</summary>
            <returns>An array containing copies of the elements of the collection.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.ToList">
            <summary>
            Returns an array containing a snapshot of the list's contents, using
            the target list node as the head of a region in the list.
            </summary>
            <param name="head">The head of a list.</param>
            <returns>An array of the list's contents.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for items in the
            collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for the items in the
            collection.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.IEnumerator"/> for items in the
            collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the items in the
            collection.</returns>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentQueue`1.Count">
            <summary>
            Gets the number of elements contained in the <see
            cref="T:System.Threading.Collections.ConcurrentQueue{T}"/>.
            </summary>
            <value>The number of elements contained in the collection.</value>
            <remarks>This is an O(N) operation.</remarks>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentQueue`1.IsEmpty">
            <summary>
            Gets whether the <see cref="T:System.Threading.Collections.ConcurrentQueue{T}"/> is empty.
            </summary>
            <value>Whether the collection is empty.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is suggested
            rather than retrieving the number of items from the <see cref="P:System.Threading.Collections.ConcurrentQueue`1.Count"/> property and comparing it
            to 0.
            </remarks>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see
            cref="T:System.Collections.ICollection"/> is synchronized.</summary>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
            <summary>Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>.</summary>
        </member>
        <member name="T:System.Threading.Collections.ConcurrentQueue`1.Node">
            <summary>
            A simple (internal) node type used to store elements of concurrent stacks and queues.
            </summary>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentQueue`1.Node.#ctor(`0)">
            <summary>
            Constructs a new node with the specified value and no next node.
            </summary>
            <param name="value">The value of the node.</param>
        </member>
        <member name="T:System.Threading.Collections.SystemThreadingCollections_ConcurrentQueueDebugView`1">
            <summary>
            A debugger view of the concurrent queue that makes it simple to browse its contents.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.SystemThreadingCollections_ConcurrentQueueDebugView`1.#ctor(System.Threading.Collections.ConcurrentQueue{`0})">
            <summary>
            Constructs a new debugger view object for the provided queue object.
            </summary>
            <param name="queue">A queue to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.Collections.SystemThreadingCollections_ConcurrentQueueDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying queue's elements.
            </summary>
        </member>
        <member name="T:System.Threading.Collections.ConcurrentStack`1">
            <summary>
            Represents a variable size last-in-first-out (LIFO) collection of instances of the same arbitrary
            type.
            </summary>
            <typeparam name="T">Specifies the type of elements in the stack.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Collections.ConcurrentStack{T}"/>
            class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" -->
        <member name="M:System.Threading.Collections.ConcurrentStack`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Collections.ConcurrentStack{T}"/>
            class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Threading.Collections.ConcurrentStack{T}"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Collections.ConcurrentStack`1.CopyTo(`0[],System.Int32)" -->
        <member name="M:System.Threading.Collections.ConcurrentStack`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about
            the collection.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the collection.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.OnDeserialization(System.Object)">
            <summary>
            Implements the <see cref="T:System.ISerializable"/> interface and is called back by the
            deserialization event when deserialization is complete.
            </summary>
            <param name="sender">The source of the deserialization event.</param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.Push(`0)">
            <summary>
            Inserts an object at the top of the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>. The value can be null for reference
            types.
            </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.PushCore(System.Threading.Collections.ConcurrentStack{`0}.Node)">
            <summary>
            Slow path helper for Push. This method assumes an initial attempt to push an element
            has already occurred and failed, so it begins spinning right away.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>. The value can be null for reference
            types.
            </param>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.System#Threading#Collections#IConcurrentCollection{T}#Add(`0)">
            <summary>
            Inserts an object at the top of the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>. The value can be null for reference
            types.
            </param>
            <returns>True if an element was successfully added; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.TryPeek(`0@)">
            <summary>
            Returns the object at the top of the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/> without removing it.
            </summary>
            <param name="result">
            When this method returns, if the peek successed, contains the object. If no object was available,
            the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was available; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.TryPop(`0@)">
            <summary>
            Removes and returns the object at the top of the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>. The return value indicates whether an
            object was successfully removed.
            </summary>
            <param name="result">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.TryPopCore(`0@)">
            <summary>
            Slow path helper for TryPop. This method assumes an initial attempt to pop an element
            has already occurred and failed, so it begins spinning right away.
            </summary>
            <param name="result">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.System#Threading#Collections#IConcurrentCollection{T}#Remove(`0@)">
            <summary>
            Removes and returns the object at the top of the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>. The return value indicates whether an
            object was successfully removed.
            </summary>
            <param name="result">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if an element was removed and returned; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.ToArray">
            <summary>Copies the items from the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/> instance into a new array.</summary>
            <returns>An array containing copies of the elements of the collection.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.ToList">
            <summary>
            Returns an array containing a snapshot of the list's contents, using
            the target list node as the head of a region in the list.
            </summary>
            <param name="head">The head of a list.</param>
            <returns>An array of the list's contents.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for items in the
            collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for the items in the
            collection.</returns>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.IEnumerator"/> for items in the
            collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the items in the
            collection.</returns>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentStack`1.IsEmpty">
            <summary>
            Gets whether the <see cref="T:System.Threading.Collections.ConcurrentStack{T}"/> is empty.
            </summary>
            <value>Whether the collection is empty.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is suggested
            rather than retrieving the number of items from the <see cref="P:System.Threading.Collections.ConcurrentStack`1.Count"/> property and comparing it
            to 0.
            </remarks>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentStack`1.Count">
            <summary>
            Gets the number of elements contained in the <see
            cref="T:System.Threading.Collections.ConcurrentStack{T}"/>.
            </summary>
            <value>The number of elements contained in the collection.</value>
            <remarks>This is an O(N) operation.</remarks>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see
            cref="T:System.Collections.ICollection"/> is synchronized.</summary>
        </member>
        <member name="P:System.Threading.Collections.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
            <summary>Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>.</summary>
        </member>
        <member name="T:System.Threading.Collections.ConcurrentStack`1.Node">
            <summary>
            A simple (internal) node type used to store elements of concurrent stacks and queues.
            </summary>
        </member>
        <member name="M:System.Threading.Collections.ConcurrentStack`1.Node.#ctor(`0)">
            <summary>
            Constructs a new node with the specified value and no next node.
            </summary>
            <param name="value">The value of the node.</param>
        </member>
        <member name="T:System.Threading.Collections.SystemThreadingCollections_ConcurrentStackDebugView`1">
            <summary>
            A debugger view of the concurrent stack that makes it simple to browse the
            stack's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Threading.Collections.SystemThreadingCollections_ConcurrentStackDebugView`1.#ctor(System.Threading.Collections.ConcurrentStack{`0})">
            <summary>
            Constructs a new debugger view object for the provided stack object.
            </summary>
            <param name="stack">A stack to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.Collections.SystemThreadingCollections_ConcurrentStackDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying stack's elements.
            </summary>
        </member>
        <member name="T:System.Threading.CountdownEvent">
            <summary>
            Represents a synchronization primitive that is signaled when its count reaches zero.
            </summary>
        </member>
        <member name="T:System.Threading.ISupportsCancellation">
            <summary>
            Indicates to callers than an object may be "canceled" in some manner. It offers a method to initiate
            asynchronous cancellation and provides a property to inquire for whether a cancellation request has
            been issued.
            </summary>
        </member>
        <member name="M:System.Threading.ISupportsCancellation.Cancel">
            <summary>
            Asynchronously cancels the instance.
            </summary>
            <remarks>
            There are no guarantees that the cancellation request will succeed, nor is it prohibited for <see cref="M:System.Threading.ISupportsCancellation.Cancel"/> to execute synchronously, blocking until the cancellation succeeds.
            </remarks>
        </member>
        <member name="P:System.Threading.ISupportsCancellation.IsCanceled">
            <summary>
            Gets whether a cancellation request has been issued on this instance.
            </summary>
            <value>Whether a cancellation request has been issued on this instance.</value>
        </member>
        <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:System.Threading.CountdownEvent"/> class with the
            specified count.
            </summary>
            <param name="count">The number of signals required to set the <see
            cref="T:System.Threading.CountdownEvent"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Dispose">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.CountdownEvent"/>.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent"/>, <see cref="M:System.Threading.CountdownEvent.Dispose"/> is not thread-safe and may not be used concurrently with any other
            members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.CountdownEvent"/>.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent"/>, <see cref="M:System.Threading.CountdownEvent.Dispose(System.Boolean)"/> is not thread-safe and may not be used concurrently with any other members of
            this instance.
            </remarks>
            <param name="disposing">True if being called due to <see cref="M:System.Threading.CountdownEvent.Dispose"/>, false if due to
            finalization.</param>
        </member>
        <member name="M:System.Threading.CountdownEvent.Decrement">
            <summary>
            Registers a signal with the <see cref="T:System.Threading.CountdownEvent"/> by decrementing its
            count.
            </summary>
            <remarks> If this signal transitions the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> to zero, the event state is
            set to signaled, allowing one or more waiting threads to proceed.
            </remarks>
            <returns>True if the event became set; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.CountdownEvent"/> is already set.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Decrement(System.Int32)">
            <summary>
            Registers a specified number of signals with the <see cref="T:System.Threading.CountdownEvent"/>
            by decrementing its count.
            </summary>
            <remarks> If these signals transition the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> to zero, the event state is
            set to signaled, allowing one or more waiting threads to proceed.
            </remarks>
            <param name="count">The number of signals to register.</param>
            <returns>True if the event became set; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.CountdownEvent"/> is already set, or the specified <paramref name="count"/>
            is larger than the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="count"/> is
            not positive.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Increment">
            <summary>
            Increments the event's count by one.
            </summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.CountdownEvent"/> is already set.</exception>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> is already at
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.TryIncrement">
            <summary>
            Attempts to increment the event's count by one.
            </summary>
            <returns>True if the increment succeeded; false if the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> was already at zero.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> is already at
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Increment(System.Int32)">
            <summary>
            Increments the event's count by a specified value.
            </summary>
            <param name="count">The value by which to increase the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="count"/> is
            not positive.</exception>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.CountdownEvent"/> is already set.</exception>
            <exception cref="T:System.InvalidOperationException">The new <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> would exceed
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.TryIncrement(System.Int32)">
            <summary>
            Attempts to increment the event's count by a specified value.
            </summary>
            <param name="count">The value by which to increase the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/>.</param>
            <returns>True if the increment succeeded; false if the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> was already at zero.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="count"/> is
            not positive.</exception>
            <exception cref="T:System.InvalidOperationException">The new <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> would exceed
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.ThrowIfDisposed">
            <summary>
            Throws an exception if the latch has been disposed.
            </summary>
        </member>
        <member name="M:System.Threading.CountdownEvent.ThrowIfCanceled">
            <summary>
            Throws an exception if the latch has been canceled.
            </summary>
        </member>
        <member name="M:System.Threading.CountdownEvent.Cancel">
            <summary>
            Cancels the event by waking all blocked threads.
            </summary>
            <remarks>
            Any blocked threads will throw a <see
            cref="T:System.OperationCanceledException"/> once they are
            unblocked. Subsequent attempts to wait on this event will also throw an OperationCanceledException.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Reset">
            <summary>
            Resets the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> to the <see cref="P:System.Threading.CountdownEvent.InitialCount"/> count.
            </summary>
            <remarks>
            Unlike most members of <see cref="T:System.Threading.CountdownEvent"/>, this method
            is not thread-safe and may not be used concurrently with members on this instance.
            </remarks>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
            <summary>
            Resets the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> to the supplied count.
            </summary>
            <param name="count">The new number of signals required to set the <see cref="T:System.Threading.CountdownEvent"/>.</param>
            <remarks>
            Unlike most members of <see cref="T:System.Threading.CountdownEvent"/>, this method is not
            thread-safe and may not be used concurrently with members on this instance.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="count"/> is
            negative.</exception>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Wait">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent"/> is set.
            </summary>
            <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
            <exception cref="T:System.OperationCanceledException">The <see
            cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent"/> is set, or
            until the specified timeout expires.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <see cref="T:System.Threading.CountdownEvent"/> was set within the allotted
            time; otherwise, false.</returns>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent"/> is set, or
            until the specified timeout expires.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the <see cref="T:System.Threading.CountdownEvent"/> was set within the allotted
            time; otherwise, false.</returns>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.CountdownEvent"/> is canceled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="P:System.Threading.CountdownEvent.CurrentCount">
            <summary>
            Gets the numbers of signals remaining before the event is set.
            </summary>
            <value>
            The number of signals remaining before the event is set.
            </value>
            <remarks>
            If the <see cref="P:System.Threading.CountdownEvent.CurrentCount"/> is zero, the event is set.
            </remarks>
        </member>
        <member name="P:System.Threading.CountdownEvent.InitialCount">
            <summary>
            Gets the numbers of signals initially required for the event to be set.
            </summary>
            <value>
            The number of signals initially required for the event is set.
            </value>
        </member>
        <member name="P:System.Threading.CountdownEvent.IsSet">
            <summary>
            Gets whether the event is set.
            </summary>
            <value>Whether the event is set.</value>
        </member>
        <member name="P:System.Threading.CountdownEvent.IsCanceled">
            <summary>
            Gets whether the event is canceled.
            </summary>
            <value>Whether the event is canceled.</value>
        </member>
        <member name="P:System.Threading.CountdownEvent.WaitHandle">
            <summary>
            Returns a <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the event.
            </summary>
            <value>A <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the event.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.CountdownEvent"/> has been disposed.</exception>
        </member>
        <member name="T:System.Threading.LazyInit`1">
            <summary>
            Provides support for several common patterns of thread-safe lazy initialization.
            </summary>
            <typeparam name="T">Specifies the type of element being laziliy initialized.</typeparam>
        </member>
        <member name="M:System.Threading.LazyInit`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.LazyInit{T}"/>
            structure using a specified initialization function.
            </summary>
            <param name="valueSelector">
            The <see cref="T:System.Func{T}"/> to invoke in order to produce the lazily-initialized value.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <remarks>
            Uses <see cref="F:System.Threading.LazyInitMode.AllowMultipleExecution"/> as the mode of
            lazy initialization.
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInit`1.#ctor(System.Func{`0},System.Threading.LazyInitMode)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.LazyInit{T}"/>
            structure using a specified initialization function and a specified mode.
            </summary>
            <param name="valueSelector">
            The <see cref="T:System.Func{T}"/> to invoke in order to produce the lazily-initialized value.
            </param>
            <param name="mode">Determines when and how the <see cref="T:System.Threading.LazyInit{T}"/>
            executes the valueSelector and stores the result
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="mode"/> argument
            specifies an invalid value.</exception>
        </member>
        <member name="M:System.Threading.LazyInit`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.LazyInit{T}"/>
            structure with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the object.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="M:System.Threading.LazyInit`1.Equals(System.Threading.LazyInit{`0})">
            <summary>
            Indicates whether the current <see cref="T:System.Threading.LazyInit{T}"/> is equal to the
            specified object.
            </summary>
            <param name="other">A <see cref="T:System.Threading.LazyInit{T}"/> to compare with this object.</param>
            <returns>True if the current object is equal to <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.LazyInit`1.Equals(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:System.Threading.LazyInit{T}"/> is equal to the
            specified object.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>True if the current object is equal to <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.LazyInit`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about
            the object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the object.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.LazyInit{T}"/> was initialized with
            <see cref="T:System.Threading.LazyInitMode"/> and cannot be serialized.
            </exception>
        </member>
        <member name="M:System.Threading.LazyInit`1.GetHashCode">
            <summary>Serves as a hash function for this <see cref="T:System.Threading.LazyInit{T}"/>.</summary>
            <returns>If the instance has not been initialized, returns 0; otherwise, returns the result of
            calling <see cref="M:System.Object.GetHashCode"/> on the <see cref="P:System.Threading.LazyInit`1.Value"/>.</returns>
            <exception cref="T:System.MissingMemberException">
            The <see cref="T:System.Threading.LazyInit{T}"/> was initialized with the default constructor and
            the type being lazily initialized does not have a public, parameterless constructor.
            </exception>
        </member>
        <member name="M:System.Threading.LazyInit`1.ToString">
            <summary>Returns a string representation of this instance.</summary>
            <returns>Returns the result of calling <see cref="M:System.Object.ToString"/> on the <see cref="P:System.Threading.LazyInit`1.Value"/>.</returns>
            <exception cref="T:System.MissingMemberException">
            The <see cref="T:System.Threading.LazyInit{T}"/> was initialized with the default constructor and
            the type being lazily initialized does not have a public, parameterless constructor.
            </exception>
        </member>
        <member name="M:System.Threading.LazyInit`1.CreateValue">
            <summary>Creates an instance of T using m_valueSelector in case its not null or use reflection to create a new T()</summary>
            <returns>An instance of T.</returns>
            <exception cref="T:System.MissingMemberException">The struct was initialized with the default ctor and 
            T does not have a public parameterless ctor.</exception>
            <exception cref="T:System.InvalidOperationException">The valueSelector returned null.</exception>
        </member>
        <member name="P:System.Threading.LazyInit`1.ValueForDebugDisplay">
            <summary>Gets the value of the LazyInit&lt;T&gt; for debugging display purposes. It takes care of getting
            the value for the current thread in the ThreadLocal mode.</summary>
        </member>
        <member name="P:System.Threading.LazyInit`1.Mode">
            <summary>Gets the <see cref="T:System.Threading.LazyInitMode"/> for this instance.</summary>
            <value>The <see cref="T:System.Threading.LazyInitMode"/> for this instance.</value>
        </member>
        <member name="P:System.Threading.LazyInit`1.IsInitialized">
            <summary>Gets whether <see cref="P:System.Threading.LazyInit`1.Value"/> is initialized.</summary>
            <value>Whether <see cref="P:System.Threading.LazyInit`1.Value"/> is initialized.</value>
            <remarks>
            If the <see cref="P:System.Threading.LazyInit`1.Mode"/> was set to <see cref="F:System.Threading.LazyInitMode.ThreadLocal"/>,
            this gets whether <see cref="P:System.Threading.LazyInit`1.Value"/> has been initialized on the current thread.
            </remarks>
        </member>
        <member name="P:System.Threading.LazyInit`1.Value">
            <summary>Gets the lazily initialized value.</summary>
            <value>The lazily initialized value.</value>
            <remarks>
            If <see cref="P:System.Threading.LazyInit`1.IsInitialized"/> is false, invoking <see cref="P:System.Threading.LazyInit`1.Value"/> will force initialization.
            </remarks>
            <exception cref="T:System.MissingMemberException">
            The <see cref="T:System.Threading.LazyInit{T}"/> was initialized with the default constructor and
            the type being lazily initialized does not have a public, parameterless constructor.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The initialization function provided to the constructor cannot access the <see cref="P:System.Threading.LazyInit`1.Value"/> of
            this instance.
            </exception>
        </member>
        <member name="T:System.Threading.LazyInit`1.SystemThreading_LazyInitDebugView">
            <summary>A debugger view of the LazyInit&lt;T&gt; to surface additional debugging properties and 
            to ensure that the LazyInit&lt;T&gt; does not become initialized if it was not already.</summary>
        </member>
        <member name="M:System.Threading.LazyInit`1.SystemThreading_LazyInitDebugView.#ctor(System.Threading.LazyInit{`0})">
            <summary>Constructs a new debugger view object for the provided LazyInit object.</summary>
            <param name="value">A LazyInit object to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.LazyInit`1.SystemThreading_LazyInitDebugView.Mode">
            <summary>Returns the mode of the LazyInit object.</summary>
        </member>
        <member name="P:System.Threading.LazyInit`1.SystemThreading_LazyInitDebugView.Initialized">
            <summary>Returns whether the LazyInit object is initialized or not.</summary>
        </member>
        <member name="P:System.Threading.LazyInit`1.SystemThreading_LazyInitDebugView.Value">
            <summary>Returns the value of the LazyInit object.</summary>
        </member>
        <member name="T:System.Threading.LazyInitMode">
            <summary>Specifies the mode of operation for a <see cref="T:System.Threading.LazyInit{T}"/> object.</summary>
        </member>
        <member name="F:System.Threading.LazyInitMode.AllowMultipleExecution">
            <summary>
            The initialization function may be executed multiple times if multiple threads race to initialize
            the value, but only one value will be published for all threads to access.
            </summary>
        </member>
        <member name="F:System.Threading.LazyInitMode.EnsureSingleExecution">
            <summary>
            The initialization function will only be executed once, even if multiple threads race to
            initialize the value. This value will be published for all threads to access.
            </summary>
        </member>
        <member name="F:System.Threading.LazyInitMode.ThreadLocal">
            <summary>
            The initialization function will be invoked once per thread that such that each thread will get
            its own published value.
            </summary>
        </member>
        <member name="T:System.Threading.SemaphoreSlim">
            <summary>
            Limits the number of threads that can access a resource or pool of resources concurrently. 
            </summary>
            <remarks>
            The <see cref="T:System.Threading.SemaphoreSlim"/> provides a lightweight semaphore class that doesn't use Windows kernel semaphores.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim"/> class, specifying
            the initial number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="initialCount"/>
            argument is negative.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim"/> class, specifying
            the initial and maximum number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
            <param name="maxCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="initialCount"/>
            argument is negative, <paramref name="initialCount"/> is greater than <paramref name="maxCount"/>,
            or <paramref name="maxCount"/> is not positive.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait">
            <summary>
            Decrements <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/> by one if it greater than zero. If <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/>
            is zero, blocks the current thread until it's greater than zero.
            </summary>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
            <summary>
            Decrements <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/> by one if it greater than zero. If <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/>
            is zero, blocks the current thread until <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/> is greater than zero or until
            a specified timeout expires.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the decrement request was granted within the allotted time; otherwise,
            false.</returns>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
            <summary>
            Decrements <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/> by one if it greater than zero. If <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/>
            is zero, blocks the current thread until <see cref="P:System.Threading.SemaphoreSlim.CurrentCount"/> is greater than zero or until
            a specified timeout expires.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the decrement request was granted within the allotted time; otherwise,
            false.</returns>
            <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.UpdateTimeOut(System.Diagnostics.Stopwatch,System.Int32)">
            <summary>
            Helper function to measure and update the wait time
            </summary>
            <param name="stopWatch"> The StopWatch object used to measure the time</param>
            <param name="originalWaitTime">The orginal wait time</param>
            <returns>The new wait time, -1 if the time expired</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release">
            <summary>
            Exits the semaphore and returns the previous count.
            </summary>
            <returns>The count on the semaphore before the Release method was called.</returns>
            <exception cref="T:System.OperationCanceledException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
            <summary>
            Exits the semaphore a specified number of times and returns the previous count.
            </summary>
            <param name="releaseCount">The number of times to exit the semaphore.</param>
            <returns>The count on the semaphore before the Release method was called.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="releaseCount"/> must
            be positive.</exception>
            <exception cref="T:System.Threading.SemaphoreFullException">The new count of the seamphore would
            exceed the maximum count.</exception>
            <exception cref="T:System.OperationCanceledException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Cancel">
            <summary>
            Sets the sempahore into an canceled state.
            </summary>
            <remarks>
            Any threads currently blocked in wait operations will wake up with an OperationCanceledException,
            and any future calls to methods on the <see cref="T:System.Threading.SemaphoreSlim"/> will also
            result in an OperationCanceledException.
            </remarks>
            <exception cref="T:System.OperationCanceledException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <remarks>
            <see cref="M:System.Threading.SemaphoreSlim.Dispose"/> should not be called while any threads are waiting on the semaphore, as
            whether they are woken when it’s disposed is undefined.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <param name="disposing">True if being called due to <see cref="M:System.Threading.SemaphoreSlim.Dispose"/>, false if due to
            finalization.</param>
            <remarks>
            <see cref="M:System.Threading.SemaphoreSlim.Dispose"/> should not be called while any threads are waiting on the semaphore, as
            whether they are woken when it’s disposed is undefined.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.CheckCancellation">
            <summary>
            Local helper method to check the interruption and throw exception if it is interrupted
            </summary>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.CheckDispose">
            <summary>
            Checks the dispose status by checking the lock object, if it is null means that object
            has been disposed and throw ObjectDisposedException
            </summary>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
            <summary>
            Gets the current count of the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <value>The current count of the <see cref="T:System.Threading.SemaphoreSlim"/>.</value>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.IsCanceled">
            <summary>
            Gets whether the event is canceled.
            </summary>
            <value>Whether the event is canceled.</value>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
            <summary>
            Returns a <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the semaphore.
            </summary>
            <value>A <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the
            semaphore.</value>
            <remarks>
            A successful wait on the <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle"/> does not imply a successful wait on
            the <see cref="T:System.Threading.SemaphoreSlim"/> itself. <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle"/> exists
            to allow a thread to block waiting on multiple semaphores, but such a wait should be followed by
            a true wait on the target semaphore.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="T:System.Threading.ManualResetEventSlim">
            <summary>
            Provides a slimmed down version of <see cref="T:System.Threading.ManualResetEvent"/>.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class to an unset state.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class to a specified state.
            </summary>
            <param name="initialState">The initial set state of the event.</param>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class to a specified state.
            </summary>
            <param name="initialState">The initial set state of the event.</param>
            <param name="spinCount">The number of spins before falling back to a true wait.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="spinCount"/> argument
            is negative.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Initialize(System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Initializes the internal state of the event.
            </summary>
            <param name="initialState">Whether the event is set initially or not.</param>
            <param name="spinCount">The spin count that decides when the event will block.</param>
            <param name="useDynamicSpinAdjustment">Whether to use dynamic spin count adjustment.</param>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.LazyInitializeEvent">
            <summary>
            This method lazily initializes the event object. It uses CAS to guarantee that
            many threads racing to call this at once don't result in more than one event
            being stored and used. The event will be signaled or unsignaled depending on
            the state of the thin-event itself, with synchronization taken into account.
            </summary>
            <returns>True if a new event was created and stored, false otherwise.</returns>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Set">
            <summary>
            Sets the event, possibly waking up any waiting threads.
            </summary>
            <remarks>
            Setting the event will wake up any threads blocked waiting on the event.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Reset">
            <summary>
            Resets the event to the unsignaled state.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.ManualResetEventSlim"/> is set.
            </summary>
            <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.ManualResetEventSlim"/> is set, or
            until the specified timeout expires.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set within the allotted
            time; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
            <summary>
            Blocks the current thread until the <see cref="T:System.Threading.ManualResetEventSlim"/> is set, or
            until the specified timeout expires.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set within the allotted
            time; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.WaitAny(System.Threading.ManualResetEventSlim[])">
            <summary>
            WaitAny simulates a Win32-style WaitAny on the set of thin-events.
            </summary>
            <param name="events">An array of thin-events (null elements permitted)</param>
            <returns>The index of the specific event in events that caused us to wake up.</returns>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Dispose">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.ManualResetEventSlim"/>.
            </summary>
            <remarks>
            Dispose should not be used concurrently with the object returned from <see cref="P:System.Threading.ManualResetEventSlim.WaitHandle"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the <see cref="T:System.Threading.ManualResetEventSlim"/>.
            </summary>
            <param name="disposing">True if being called due to <see cref="M:System.Threading.ManualResetEventSlim.Dispose"/>, false if due to
            finalization.</param>
            <remarks>
            Dispose should not be used concurrently with the object returned from <see cref="P:System.Threading.ManualResetEventSlim.WaitHandle"/>.
            </remarks>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.IsSet">
            <summary>
            Gets whether the event is set.
            </summary>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
            <summary>
            Gets the underlying Win32 event object for this <see
            cref="T:System.Threading.ManualResetEventSlim"/>.
            </summary>
            <remarks>
            Accessing this property forces initialization of an underlying Win32 event object if one hasn't
            already been created.
            </remarks>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.UseDynamicSpinAdjustment">
            <summary>
            Whether we should use dynamic spin count adjustment.
            </summary>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
            <summary>
            Gets the number of spins that will be used before falling back to a true wait.
            </summary>
        </member>
        <member name="T:System.Threading.SpinWait">
            <summary>
            Provides support for common spinning logic.
            </summary>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce">
            <summary>
            Performs a single Spin iteration.
            </summary>
            <remarks>
            This is typically called in a loop, and may change is behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.Reset">
            <summary>
            Resets the internal spin counter. This makes the Spin API behave as though the next
            call were its first. If a SpinWait object is reused many times, you will want to reset
            it to avoid accidentally yielding too soon, etc.
            </summary>
        </member>
        <member name="P:System.Threading.SpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:System.Threading.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:System.Threading.SpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:System.Threading.SpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="T:System.Threading.WriteOnce`1">
            <summary>
            Provides support for single-assignment variables.
            </summary>
            <typeparam name="T">Specifies the type of single-assignment variable.</typeparam>
        </member>
        <member name="M:System.Threading.WriteOnce`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.WriteOnce{T}"/>
            structure using a specified value.
            </summary>
            <param name="value">The value for this <see cref="T:System.Threading.WriteOnce{T}"/> instance.</param>
        </member>
        <member name="M:System.Threading.WriteOnce`1.TryGetValue(`0@)">
            <summary>
            Retrieve the instance's value if it's been initialized.
            </summary>
            <param name="value">
            When this method returns, if the get suceeded, contains the instance's value. If the instance's
            value is not yet set, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>True if the value could be retrieved; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="M:System.Threading.WriteOnce`1.TrySetValue(`0)">
            <summary>
            Sets the instance's value if it has not yet been initialized.
            </summary>
            <param name="value">The value to set.</param>
            <returns>True if the value could be set; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="M:System.Threading.WriteOnce`1.TrySet(System.Threading.WriteOnce{`0}.WriteOnceData)">
            <summary>
            Tryaet the variable to WOD instance
            </summary>
            <param name="data">The WOD instance</param>
            <returns>True if succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Threading.WriteOnce`1.HasValueOrThrowIfCorrupted">
            <summary>
            Checks if the variable is set or not, also throws exception if the instance is corrupted
            Grombined in one function because in all cases in this code HasValue is called after ThrowIfCorrupted
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Threading.WriteOnce`1.Equals(System.Threading.WriteOnce{`0})">
            <summary>
            Indicates whether the current <see cref="T:System.Threading.WriteOnce{T}"/> is equal to the
            specified object.
            </summary>
            <param name="other">A <see cref="T:System.Threading.WriteOnce{T}"/> to compare with this object.</param>
            <returns>True if the current object is equal to <paramref name="other"/>; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="M:System.Threading.WriteOnce`1.Equals(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:System.Threading.WriteOnce{T}"/> is equal to the
            specified object.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>True if the current object is equal to <paramref name="other"/>; otherwise,
            false.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="M:System.Threading.WriteOnce`1.GetHashCode">
            <summary>Serves as a hash function for this <see cref="T:System.Threading.WriteOnce{T}"/>.</summary>
            <returns>If the instance has not been initialized or has been initialized to a non-null value,
            returns 0; otherwise, returns the result of calling <see cref="M:System.Object.GetHashCode"/> on
            the <see cref="P:System.Threading.WriteOnce`1.Value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="M:System.Threading.WriteOnce`1.ToString">
            <summary>Returns a string representation of this instance.</summary>
            <returns>
            If the <see cref="P:System.Threading.WriteOnce`1.Value"/> is not null, returns the result of calling <see cref="M:System.Object.ToString"/> on the <see cref="P:System.Threading.WriteOnce`1.Value"/>; otherwise, returns an empty
            string.</returns>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.WriteOnce{T}"/> is corrupted due to a previous invalid call to
            <see cref="P:System.Threading.WriteOnce`1.Value"/>.
            </exception>
        </member>
        <member name="P:System.Threading.WriteOnce`1.HasValue">
            <summary>
            Gets whether the <see cref="T:System.Threading.WriteOnce{T}"/> has been set with a value.
            </summary>
            <value>Whether the <see cref="T:System.Threading.WriteOnce{T}"/> has been set with a value.</value>
        </member>
        <member name="P:System.Threading.WriteOnce`1.Value">
            <summary>
            Gets or sets the value of this <see cref="T:System.Threading.WriteOnce{T}"/>.
            </summary>
            <value>The value of this <see cref="T:System.Threading.WriteOnce{T}"/></value>
            <exception cref="T:System.InvalidOperationException">
            An attempt was made to retrieve the value, but no value had been set, or an attempt was made to
            set the value when the value was already set.
            </exception>
            <remarks>
            If an attempt is made to get the <see cref="P:System.Threading.WriteOnce`1.Value"/> of this <see cref="T:System.Threading.WriteOnce{T}"/>
            before it has been set, the instance will be corrupted for feature attempts to both get and set
            the value.
            </remarks>
        </member>
        <member name="P:System.Threading.WriteOnce`1.ValueDebugAttribute">
            <summary>
            Gets the variable value, it is used by the DebuggerDisplayAttribute
            </summary>
        </member>
        <member name="P:System.Threading.WriteOnce`1.IsValid">
            <summary>
            Internal property gets if the current instance is corrupted or not
            </summary>
        </member>
        <member name="T:System.Threading.WriteOnce`1.WriteOnceData">
            <summary>
            This is a private wrapper class to wrap the T into a reference type that will be used by CAS 
            </summary>
        </member>
        <member name="M:System.Threading.WriteOnce`1.WriteOnceData.#ctor(`0,System.Boolean)">
            <summary>
            WriteOnceData constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:System.Threading.WriteOnce`1.SystemThreading_WriteOnceDebugView">
            <summary>
            Displays the IsValid property, used by the DebuggerTypeProxy
            </summary>
        </member>
        <member name="T:System.Threading.SpinLock">
            <summary>
            Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop
            repeatedly checking until the lock becomes available.
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock"/>
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <param name="enableThreadOwnerTracking">Whether to capture and use thread IDs for debugging purposes.</param>
        </member>
        <member name="M:System.Threading.SpinLock.Enter">
            <summary>
            Acquires the <see cref="T:System.Threading.SpinLock"/>.
            </summary>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <remarks>
            Blocks the current thread until the lock is acquired.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter">
            <summary>
            Attempts to acquire the <see cref="T:System.Threading.SpinLock"/>.
            </summary>
            <returns>True if the lock was successfully acquired; otherwise, false.</returns>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter"/>, <see cref="M:System.Threading.SpinLock.TryEnter"/> will not block waiting for the lock to be
            available.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan)">
            <summary>
            Attempts to acquire the <see cref="T:System.Threading.SpinLock"/>.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>True if the lock was successfully acquired; otherwise, false.</returns>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Int32)">
            <summary>
            Attempts to acquire the <see cref="T:System.Threading.SpinLock"/>.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the lock was successfully acquired; otherwise, false.</returns>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.ReliableEnter(System.Boolean@)">
            <summary>
            Acquires the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="tookLock"/> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryReliableEnter(System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="tookLock"/> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter"/>, <see cref="M:System.Threading.SpinLock.TryEnter"/> will not block waiting for the lock to be
            available.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinLock.TryReliableEnter(System.TimeSpan,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="tookLock"/> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryReliableEnter(System.Int32,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="tookLock"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            The current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="lockTaken"/>
            is set to true.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnterCore(System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            An internal helper used by both unreliable and reliable acquires. Contains common logic to
            catch recursive acquires, CAS the lock state, and spin as needed. Also uses CERs internally
            to implement reliable acquires.
            </summary>
            <param name="millisecondsTimeout">An approximate timeout before returning false.</param>
            <param name="lockTaken">set to true if the lock is acquired; otherwise, it’s set to false</param>
        </member>
        <member name="M:System.Threading.SpinLock.TimeoutExpired(System.Int64,System.Int32)">
            <summary>
            Helper function to validate the timeout
            </summary>
            <param name="startTicks"> The start time in ticks</param>
            <param name="originalWaitTime">The orginal wait time</param>
            <returns>True if expired, false otherwise</returns>
        </member>
        <member name="M:System.Threading.SpinLock.Exit">
            <summary>
            Releases the lock.
            </summary>
            <exception cref="T:System.Threading.SynchronizationLockException">The current thread is not the owner of this lock.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
            <summary>
            Releases the lock.
            </summary>
            <param name="flushReleaseWrite">
            If true, flushes the write buffers associated with this lock in order to ensure that all
            processors are immediately made aware that the lock is now available.
            </param>
            <exception cref="T:System.Threading.SynchronizationLockException">
            The current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
            <summary>
            Gets whether the lock is acquired.  If the lock was initialized to track owner threads, this
            will return whether the lock is acquired by the current thread; otherwise, it will return
            whether the lock is acquired by any thread.
            </summary>
            <value>Whether the lock is acquired.</value>
        </member>
        <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
            <summary>Gets whether owner tracking is enabled for this instance.</summary>
            <value>Whether owner tracking is enabled for this instance.</value>
        </member>
        <member name="T:System.Threading.SpinLock.SystemThreading_SpinLockDebugView">
            <summary>
            Internal class used by debug type proxy attribute to display the owner thread ID 
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.#ctor(System.Threading.SpinLock)">
            <summary>
            SystemThreading_SpinLockDebugView constructor
            </summary>
            <param name="slock"></param>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeldByCurrentThread">
            <summary>
            Checks if the lock is held by the current thread or not
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.HolderThreadID">
            <summary>
            Gets the current owner thread, zero if it is released
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskPlatform">
            <summary>
            Internal class that abstracts over common platform specific operations.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskPlatform.YieldExponential(System.Int32@)">
            <summary>
            Wait by spinning the processor (on multi processor machines).
            </summary>
            <param name="spins">Number of cycles spend spinning. Should be zero on the initial call.</param>
            <returns>Sleep time in msecs.</returns>
        </member>
        <member name="T:System.Threading.Tasks.Statistics">
            <summary>
            Statistics to monitor the behaviour and performance of the task manager.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Statistics.ToString">
            <summary>
            Convert the statistics to a string in human readable format.
            </summary>
            <returns>The string representation of the statistics.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.Runs">
            <summary>
            The number of executed tasks.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.Switches">
            <summary>
            The number of forced thread switches.
            </summary>
            <remarks>If this number is high with respect to <see cref="P:System.Threading.Tasks.Statistics.Runs"/>,
            it can mean that there were many joins on tasks in creation
            order; try to join in reverse order, i.e. join on the last created task first.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.UsedThreads">
            <summary>
            The total number of threads used to execute the tasks.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.Steals">
            <summary>
            The number of tasks stolen from other workers.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.Migrations">
            <summary>
            The number of threads that were migrated to another processor.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.WorkerStats">
            <summary>
            Retrieve statistics per worker.
            </summary>
            <remarks>
            Usually, there is one worker per processor that executes tasks.
            Note: the sum of worker threads per worker can be lower than the
            total number of threads used due to thread migration between
            workers.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Statistics.Elapsed">
            <summary>
            Elapsed time.
            </summary>
            <remarks>
            Only set for the task manager statistics.</remarks>
        </member>
        <member name="T:System.Threading.Tasks.TaskManager">
            <summary>
            Represents a manager and scheduler of tasks.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskManager"/>
            using default policy settings.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.#ctor(System.Threading.Tasks.TaskManagerPolicy)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskManager"/>
            using the provided policy settings.</summary>
            <param name="policy">The <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/> to use for
            controlling the behavior of this <see cref="T:System.Threading.Tasks.TaskManager"/>.</param>
            <remarks>
            <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/> is immutable. In order to change a <see cref="T:System.Threading.Tasks.TaskManager"/>'s settings, a new policy needs to be stored into
            the <see cref="P:System.Threading.Tasks.TaskManager.Policy"/> property.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The policy argument is null.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have permission to use
            the specified policy.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.RunBlocking(System.Action)">
            <summary>
            Executes a potentially-blocking action synchronously.
            </summary>
            <param name="action">The action to execute.</param>
            <remarks>While the action executes, the current thread is assumed to be blocked, and extra
            threads may be used to maintain the desired concurrency level.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.RunBlocking``1(System.Func{``0})">
            <summary>
            Executes a potentially-blocking function synchronously and returns the function's return value.
            </summary>
            <typeparam name="T">The type of data returned by <paramref name="function"/>.</typeparam>
            <param name="function">The function to execute.</param>
            <returns>The return value of the executed function.</returns>
            <remarks>While the function executes, the current thread is assumed to be blocked, and
            extra threads may be used to maintain the desired concurrency level.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="function"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.InternalShutdown(System.Boolean)">
            <summary>
            Shuts down the task manager, which entails terminating all worker threads.
            </summary>
            <param name="blocking">The shutdown is blocking, i.e. it will not return
            until all worker threads have definitely stopped working.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.SchedulerShutdownEventHandler(System.Object,System.Threading.ConcurrencyScheduler.SchedulerShutdownEventArgs)">
            <summary>
            The callback function for scheduler shutdown, which gets called when scheduler shutdown is complete. 
            It simply signals the TaskManager's internal shutdown event so that a blocking <see cref="M:System.Threading.Tasks.TaskManager.Dispose"/> call can return.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.Dispose">
            <summary>
            Shuts down the <see cref="T:System.Threading.Tasks.TaskManager"/> synchronously. The <see cref="T:System.Threading.Tasks.TaskManager"/> will not be available to schedule any more work
            after <see cref="M:System.Threading.Tasks.TaskManager.Dispose"/> has been called.
            </summary>
            <exception cref="T:System.InvalidOperationException"><see cref="M:System.Threading.Tasks.TaskManager.Dispose"/> can't be used on the
            default
            <see cref="T:System.Threading.Tasks.TaskManager"/>.</exception>
            <exception cref="T:System.InvalidOperationException">A <see cref="T:System.Threading.Tasks.TaskManager"/> can't be shut down from a task executing on that
            <see cref="T:System.Threading.Tasks.TaskManager"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.Dispose(System.Boolean)">
            <summary>
            Disposes of the object's internal state.
            </summary>
            <param name="disposing">Whether being called for dispose (true) or finalization (false).</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManager.Finalize">
            <summary>
            Shuts down the <see cref="T:System.Threading.Tasks.TaskManager"/> synchronously.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManager.Default">
            <summary>Gets the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</summary>
            <value>The default <see cref="T:System.Threading.Tasks.TaskManager"/> instance.</value>
            <remarks>
            The default <see cref="T:System.Threading.Tasks.TaskManager"/> is implicitly used for scheduling
            tasks when no <see cref="T:System.Threading.Tasks.TaskManager"/> is specified explicitly or when
            <see cref="P:System.Threading.Tasks.TaskManager.Current"/> is the default <see cref="T:System.Threading.Tasks.TaskManager"/>. This property will never return null (Nothing in
            Visual Basic). If <see cref="P:System.Threading.Tasks.TaskManager.Current"/> is not equal to <see cref="P:System.Threading.Tasks.TaskManager.Default"/>, tasks can be scheduled to run on the default
            <see cref="T:System.Threading.Tasks.TaskManager"/> explicitly by passing <see cref="P:System.Threading.Tasks.TaskManager.Default"/> to the appropriate task-creation methods.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskManager.Current">
            <summary>Gets the current <see cref="T:System.Threading.Tasks.TaskManager"/>.</summary>
            <value>The current <see cref="T:System.Threading.Tasks.TaskManager"/> instance.</value>
            <remarks>
            <see cref="P:System.Threading.Tasks.TaskManager.Current"/> represents the <see cref="T:System.Threading.Tasks.TaskManager"/> that will be used to start a task if no <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been specified explicitly. <see cref="P:System.Threading.Tasks.TaskManager.Current"/> will
            return the
            <see cref="T:System.Threading.Tasks.TaskManager"/> used to start the nearest <see cref="T:System.Threading.Tasks.Task"/> in the logical call chain. As an example, if task T1 was
            started with <see cref="T:System.Threading.Tasks.TaskManager"/>
            M1, and if task T1 then started task T2 without explicitly specifying a <see cref="T:System.Threading.Tasks.TaskManager"/>, T2 would implicitly run with <see cref="T:System.Threading.Tasks.TaskManager"/> M1. Similarly, if task T2 started task T3 without
            specifying a
            <see cref="T:System.Threading.Tasks.TaskManager"/>, T3 would run with M1. However, if T3 then
            started task T4 with <see cref="T:System.Threading.Tasks.TaskManager"/> M2, and T4 started task
            T5 without explicitly specifying a <see cref="T:System.Threading.Tasks.TaskManager"/>, T5 would
            run with M2 rather than with M1. Note that if <see cref="P:System.Threading.Tasks.TaskManager.Current"/> would otherwise be unspecified, it will
            return
            <see cref="P:System.Threading.Tasks.TaskManager.Default"/>. As such, <see cref="P:System.Threading.Tasks.TaskManager.Current"/> will always return a valid <see cref="T:System.Threading.Tasks.TaskManager"/>.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskManager.Policy">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/> used by this <see cref="T:System.Threading.Tasks.TaskManager"/>.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManager.IsShutdown">
            <summary>
            Checks whether shutdown has been initiated.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskManagerPolicy">
            <summary>
            Represents a policy used to configure the behavior of a TaskManager.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/> containing the system defaults.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor(System.Int32,System.Int32)">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. System defaults
            are used for all policy values not specified.
            </summary>
            <param name="minProcessors">The minimum number of processor to use for executing tasks.</param>
            <param name="idealProcessors">The ideal number of processor to use for executing tasks.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. System defaults
            are used for all policy values not specified.
            </summary>
            <param name="minProcessors">The minimum number of processor to use for executing tasks.</param>
            <param name="idealProcessors">The ideal number of processor to use for executing tasks.</param>
            <param name="idealThreadsPerProcessor">The number of worker threads that will be created per processor.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor(System.Int32,System.Int32,System.Threading.ThreadPriority)">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. System defaults
            are used for all policy values not specified.
            </summary>
            <param name="minProcessors">The minimum number of processor to use for executing tasks.</param>
            <param name="idealProcessors">The ideal number of processor to use for executing tasks.</param>
            <param name="threadPriority">The thread priority to be set on worker threads.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor(System.Int32)">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. System defaults
            are used for all policy values not specified.
            </summary>
            <param name="maxStackSize">The maximum stack size to be used by worker threads, or 0 to use the default system stack size.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskManagerPolicy.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Threading.ThreadPriority)">
            <summary>
            Instantiates a new <see cref="T:System.Threading.Tasks.TaskManagerPolicy"/> with the supplied
            policy configuration.
            </summary>
            <param name="minProcessors">The minimum number of processor to use for executing tasks.</param>
            <param name="idealProcessors">The ideal number of processor to use for executing tasks.</param>
            <param name="idealThreadsPerProcessor">The number of worker threads that will be created per processor.</param>
            <param name="maxStackSize">The maximum stack size to be used by worker threads, or 0 to use the default system stack size.</param>
            <param name="threadPriority">The thread priority to be set on worker threads.</param>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.InternalSchedulerPolicy">
            <summary>
            Internal accessor for TaskManager to read the wrapped scheduler policy object.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.MinProcessors">
            <summary>
            Gets the minimum number of processor to use for executing tasks on this <see
            cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. The default is 1.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.IdealProcessors">
            <summary>
            Gets the ideal number of processor to use for executing tasks on this <see
            cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. The default is equal to the actual number of
            processors on the system.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.IdealThreadsPerProcessor">
            <summary>
            Gets the ideal threads per processor specified on this <see
            cref="T:System.Threading.Tasks.TaskManagerPolicy"/>, which denotes the number of worker threads that will be created
            per processor to execute tasks. The default value is 1.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.MaxStackSize">
            <summary>
            Gets the maximum stack size to be used by worker threads in this <see
            cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. A value of 0 specifies that the size
            defaults to the value in the header for the executable.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskManagerPolicy.ThreadPriority">
            <summary>
            Gets the worker thread priority specified on this <see
            cref="T:System.Threading.Tasks.TaskManagerPolicy"/>. The default is ThreadPriority.Normal.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskCanceledException">
            <summary>
            Represents an exception used to communicate task cancellation.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/> class.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/> class
            with a reference to the <see cref="T:System.Threading.Tasks.Task"/> that has been canceled.
            </summary>
            <param name="task">A task that has been canceled.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param>
        </member>
        <member name="P:System.Threading.Tasks.TaskCanceledException.Task">
            <summary>
            Gets the task associated with this exception, if any exists.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Task">
            Task waiting related static methods of the Task class are implemented in this source file
            <summary>
            Represents an asynchronous operation.
            </summary>
            <remarks><see cref="T:System.Threading.Tasks.Task"/> does not provide public constructors. Instances
            of
            <see cref="T:System.Threading.Tasks.Task"/> can only be created with factory methods present on the
            class.</remarks>
        </member>
        <member name="T:System.Threading.Tasks.TaskBase">
            <summary>
             An abstract representation of a unit of work.  
             </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.#ctor">
            <summary>
             Constructs a new TaskBase.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.Invoke">
            <summary>
             Invokes the unit of work.  This may only be called for tasks which have been removed from
             the work stealing queue on the bound thread via a Pop or TryPop operation.  Other use is restricted
             to the scheduler itself.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.InvokeStolen">
            <summary>
             Invokes the unit of work that has been stolen.  
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.Execute(System.Boolean)">
            <summary>
             This function is called by the scheduler to execute the work behind a TaskBase.  Derived classes
             need to implement this member.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.CaptureContext(System.Boolean)">
            <summary>
             Captures the .NET execution context.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskBase.InContextInvoke(System.Object)">
            <summary>
             Internal invocation within the captured execution context.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was
            thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <returns>true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances
            completed execution within the allotted time; otherwise, false.</returns>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was
            thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <returns>true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances
            completed execution within the allotted time; otherwise, false.</returns>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was
            thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.FastWaitAll(System.Threading.Tasks.Task[])">
            <summary>
            Internal WaitAll implementation which is meant to be used with small number of tasks,
            optimized for Parallel.Invoke and other structured primitives.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddExceptionsForCompletedTask(System.Collections.Generic.List{System.Exception}@,System.Threading.Tasks.Task)">
            <summary>
            This internal function is only meant to be called by WaitAll()
            If the completed task is canceled or it has other exceptions, here we will add those
            into the passed in exception list (which will be lazily initialized here).
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <returns>The index of the completed task.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>The index of the completed task, or -1 if the timeout occurred.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to
            complete execution.
            </summary>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances
            on which to wait.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>The index of the completed task, or -1 if the timeout occurred.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="tasks"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="tasks"/> argument contains a
            null element.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.Task,System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            An internal constructor used by the factory methods on task and its descendent(s).
            </summary>
            <param name="action">An action to execute.</param>
            <param name="state">Optional state to pass to the action.</param>
            <param name="taskManager">A task manager under which the task will run.</param>
            <param name="options">Options to control its execution.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddNewChild(System.Threading.Tasks.Task)">
            <summary>
            Internal function that will be called by a new child task to add itself to 
            the children list of the parent (this).
            
            Since a child task can only be created from the thread executing the action delegate
            of this task, reentrancy is neither required nor supported. This should not be called from
            anywhere other than the task construction/initialization codepaths.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object})">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Task"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> and will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object},System.Object)">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>.</param>
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Task"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> and will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object},System.Threading.Tasks.TaskManager)">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Task"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Task"/> will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Create(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            A factory method that instantiates a <see cref="T:System.Threading.Tasks.Task"/> and schedules it
            for execution.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Task"/>.</param>        
            <returns>The new <see cref="T:System.Threading.Tasks.Task"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ThrowIfDisposed">
            <summary>
            Throws an exception if the task has been disposed, and hence can no longer be accessed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The task has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.Tasks.Task"/>, releasing all of its unmanaged resources.
            </summary>
            <remarks>Unlike most of the members of <see cref="T:System.Threading.Tasks.Task"/>, this method is not thread-safe.</remarks>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Threading.Tasks.Task"/> has not completed execution.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
            <summary>
            Disposes of the internal state.
            </summary>
            <param name="disposing">Whether being called for dipose (true) or finalization (false).</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalStart">
            <summary>
            Schedules the task for execution.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddException(System.Exception)">
            <summary>
            Adds an exception to the list of exceptions this task has thrown.
            </summary>
            <param name="e">An exception object.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.GenerateAggregateException(System.Boolean)">
            <summary>
            Wraps the aggregate exception generation logic for internal codepaths that throw. The bool argument lets the caller request
            an aggregate exception that doesn't include 
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ThrowIfExceptional(System.Boolean)">
            <summary>
            Throws an aggregate exception if the task contains exceptions. 
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.UpdateExceptionObservedStatus">
            <summary>
            Checks whether this is an attached task, and whether we are being called by the parent task.
            And sets the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag based on that.
            
            This is meant to be used internally when throwing an exception, and when WaitAll is gathering 
            exceptions for tasks it waited on. If this flag gets set, the implicit wait on children 
            will skip exceptions to prevent duplication.
            
            This should only be called when this task has completed with an exception
            
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.IsExceptionObservedByParent">
            <summary>
            Checks whether the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag is set,
            This will only be used by the implicit wait to prevent double throws
            
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.CaptureExecutionContext">
            <summary>
            This method is called from the task creation path to capture the calling context.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Finish">
            <summary>
            Signals completion of this particular task.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.NotifyChildrenForCancellation">
            <summary>
            Notifies all the children that they are now canceled as well because we were canceled.
            This is meant to be called from 2 places and conditions
             - From Finish(), if the task has completed because of cancellation. 
             - From InternalCancel(), if someone attempted to Cancel() this task after the task's delegate had quit. 
               This forwards cancel requests to the children during the implicit wait, when it's safe to access m_children externally.
            
            It's only safe to call this function from the thread executing this task unless the delegate already quit
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Execute">
            <summary>
            Executes the task. This method will only be called once, and handles bookeeping associated with
            self-replicating tasks, in addition to performing necessary exception marshaling.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The task has already been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Execute(System.Boolean)">
            <summary>
            TaskBase override, which is the entry function for this task when the scheduler decides to run it.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.InnerInvoke">
            <summary>
            The actual code which invokes the body of the task. This can be overriden in derived types.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <exception cref="T:System.Threading.AggregateException">The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown
            during the execution of the <see cref="T:System.Threading.Tasks.Task"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <see cref="T:System.Threading.Tasks.Task"/> completed execution
            within the allotted time; otherwise, false.</returns>
            <exception cref="T:System.Threading.AggregateException">The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown
            during the execution of the <see cref="T:System.Threading.Tasks.Task"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.Int32)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the <see cref="T:System.Threading.Tasks.Task"/> completed execution within the
            allotted time; otherwise, false.</returns>
            <exception cref="T:System.Threading.AggregateException">The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during the
            execution of the <see cref="T:System.Threading.Tasks.Task"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalWait(System.Int32,System.Threading.ConcurrencyScheduler.Context)">
            <summary>
            The core wait function, which is only accesible internally. It's meant to be used in places in TPL code where 
            the current context is known or cached.
            </summary>        
        </member>
        <member name="M:System.Threading.Tasks.Task.TryEnter(System.Threading.ConcurrencyScheduler.Context)">
            <summary>
            This internal functions attempts to dequeue the current task, and if successful executes the delegate inline.
            Return value indicates whether the task was successfully dequeued and inlined. TryEnter is meant to be used by
            internal wait codepaths such as WaitAll and WaitForChildren
            
            IMPORTANT NOTE: TryEnter will NOT throw task exceptions itself. Any wait code path using this function needs 
            to account for exceptions that need to be propagated, and throw themselves accordingly.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitForChildren">
            <summary>
            Waits for the all the children of this task to complete execution.
            This method is used to implement the "implicit wait" functionality for structured task hierarchies, 
            which mandates that for a parent task to be marked/signaled as complete all of its "attached" children 
            must also have finished.
            
            Note that this multiple wait implementation closely resembles that of Task.WaitAll(), however it's 
            different in the following aspects:
            
            1) there is no parameter checking overhead because this will only be called with guaranteed pre-conditions
            2) wait timeout handling is skipped
            3) Exception propagation happens through AddException() rather than a direct throw.
            4) TaskDisposed exceptions, which would normally be propagated by WaitAll, are ignored here 
            for the implicit wait, because if a child was disposed it must have been completed.
            
            5) In WaitAll TaskCancellation exceptions are either explicitly generated if a task is marked as canceled, or they 
            are simply propagated if the inline wait for the task throws it. However here in the implicit wait implementation
            such standalone Task Cancellation Exceptions (i.e. not contained in an aggragate) are ignored unless cancellation came from a foreign task.
            The rationale for this is that the implicit wait should not propagate an exception based on a cancellation action which
            was initiated inside our task delegate on purpose.
            
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddExceptionsForCompletedChildTask(System.Threading.Tasks.Task)">
            <summary>
            This internal function is only meant to be called by the implicit wait, i.e. WaitForChildrend().
            All it does is add the exceptions for this completed child into our aggregate.
            If the child was canceled by a foreign task we also add a new TaskCanceledException 
            
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Cancel">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalCancel(System.Boolean,System.Int32)">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <param name="bTryPopOnly"> Indiactes whether we should only attempt to dequeue. 
            If bTryPopOnly is true and the task cannot be dequeued it will not be marked as canceled. 
            However if bTryPopOnly is false, the task will be marked as canceled even if it started execution (so the task delegate would observe IsCanceled = true)</param> 
            <returns>true if the task was successfully dequeued or marked to be canceled; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.CancelAndWait">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/> and waits for it to complete
            execution.
            </summary>
            <remarks>
            This suppresses the cancellation exception that would ordinarily arise from waiting on a canceled
            task.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.CancelAndWait(System.TimeSpan)">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/> and waits for it to complete
            execution.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <remarks>
            This suppresses the cancellation exception that would ordinarily arise from waiting on a canceled
            task.
            </remarks>
            <returns>true if the cancellation and waiting completed within the allotted time; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.CancelAndWait(System.Int32)">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/> and waits for it to complete
            execution.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <remarks>
            This suppresses the cancellation exception that would ordinarily arise from waiting on a canceled
            task.
            </remarks>
            <returns>true if the cancellation and waiting completed within the allotted time; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.FinishContinuations">
            <summary>
            Runs all of the continuations, as appropriate.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWithIsRightKind(System.Threading.Tasks.TaskContinuationKind)">
            <summary>
            Helper function to determine whether the current task is in the state desired by the
            continuation kind under evaluation. Three possibilities exist: the task failed with
            an unhandled exception (OnFailed), the task was canceled before running (OnAborted),
            or the task completed successfully (OnCompletedSuccessfully).  Note that the last
            one includes completing due to cancellation.
            </summary>
            <param name="kind">The kind of continuation under evaluation.</param>
            <returns>True if the continuation should be run given the task's current state.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Task"/>
            completes.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationKind)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Task"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Task"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Task"/>.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Task"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Task"/>.</param>
            <param name="executeSynchronously">Whether to run the continuation synchronously.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWithCore(System.Threading.Tasks.Task,System.Threading.Tasks.TaskContinuationKind,System.Boolean)">
            <summary>
            Registers the continuation and possibly runs it (if the task is already finished).
            </summary>
            <param name="continuationTask">The continuation task itself.</param>
            <param name="kind">Restrictions on when the continuation becomes active.</param>
            <param name="executeSynchronously">Whether to run the continuation synchronously.</param>
        </member>
        <member name="P:System.Threading.Tasks.Task.Id">
            <summary>
            Gets the unique ID for this <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.Current">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task"/> currently executing, or null if none exists.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.Exception">
            <summary>
            Gets the <see cref="T:System.Exception"/> that caused the <see cref="T:System.Threading.Tasks.Task"/> to end prematurely. If the <see cref="T:System.Threading.Tasks.Task"/> completed successfully or has not yet thrown any
            exceptions, this will return null.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCanceled">
            <summary>
            Gets whether a request has been made to cancel this <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
            <remarks>
            If this <see cref="T:System.Threading.Tasks.Task"/> with the
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.RespectCreatorCancellation"/> flag,
            <see cref="P:System.Threading.Tasks.Task.IsCanceled"/> will return true if the <see cref="P:System.Threading.Tasks.Task.Creator"/> of this
            <see cref="T:System.Threading.Tasks.Task"/> was canceled.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCanceledByParent">
            <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task"/> was canceled by its parent. This is an internal 
            property which is only meant to be used during the implicit wait (WaitForChildren) to determine whether TaskCanceledExceptions
            should be propagated or not. (A child task which was canceled by its own parent will not cause a TCE to be propagated from the implicit wait)
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCompleted">
            <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task"/> has completed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsDisposed">
            <summary>
            Checks whether this task has been disposed.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.Parent">
            <summary>
            Gets the parent <see cref="T:System.Threading.Tasks.Task"/> of this <see cref="T:System.Threading.Tasks.Task"/>, if one exists, or null if there is no parent.
            </summary>
            <remarks>The parent of a <see cref="T:System.Threading.Tasks.Task"/> will be null if the <see cref="F:System.Threading.Tasks.TaskCreationOptions.Detached"/> flag was explicitly set while
            the task was being created, or if it was created as a root-level task (meaning <see cref="P:System.Threading.Tasks.Task.Current"/> was null at creation time). Otherwise, the parent is
            the <see cref="T:System.Threading.Tasks.Task"/> that was current when the new <see cref="T:System.Threading.Tasks.Task"/> was created.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.Creator">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task"/> which created this <see cref="T:System.Threading.Tasks.Task"/>, if one exists, or null if there is no creator.
            </summary>
            <remarks>The creator of a <see cref="T:System.Threading.Tasks.Task"/> is the <see cref="T:System.Threading.Tasks.Task"/> that was current when the new <see cref="T:System.Threading.Tasks.Task"/> was allocated. <see cref="P:System.Threading.Tasks.Task.Creator"/> and
            <see cref="P:System.Threading.Tasks.Task.Parent"/> will be equal if <see cref="F:System.Threading.Tasks.TaskCreationOptions.Detached"/> was not specified when the task
            was created.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.TaskCreationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> used to create this task.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"/> that can be used to wait for the task to
            complete.
            </summary>
            <remarks>Using the wait functionality provided by <see cref="T:System.Threading.Tasks.Task"/>
            and <see cref="T:System.Threading.Tasks.Task"/> should be preferred over using <see cref="P:System.IAsyncResult.AsyncWaitHandle"/> for similar functionality.</remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncState">
            <summary>
            Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task"/> was created,
            or null if none was supplied.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
            <summary>
            Gets an indication of whether the asynchronous operation completed synchronously.
            </summary>
            <value>true if the asynchronous operation completed synchronously; otherwise, false.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.Tasks.Task"/>
            has been disposed.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.ExecutingTaskManager">
            <summary>
            Provides access to the TaskManager responsible for executing this Task.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.CompletedEvent">
            <summary>
            Provides an event that can be used to wait for completion.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsSelfReplicatingRoot">
            <summary>
            Determines whether this is the root task of a self replicating group.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsChildReplica">
            <summary>
            Determines whether the task is a replica itself.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsExceptional">
            <summary>
            A simple helper which indicates whether the task has thrown exceptions.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Task.TaskContinuation">
            <summary>
            A structure to hold continuation information.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.TaskContinuation.#ctor(System.Threading.Tasks.Task,System.Threading.Tasks.TaskContinuationKind,System.Boolean)">
            <summary>
            Constructs a new continuation structure.
            </summary>
            <param name="task">The task to be activated.</param>
            <param name="kind">Under what conditions to activate the task.</param>
            <param name="executeSynchronously">Whether to execute synchronously or in the pool.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.TaskContinuation.Run(System.Threading.Tasks.Task)">
            <summary>
            Invokes the continuation for the target completion task.
            </summary>
            <param name="completedTask"></param>
        </member>
        <member name="T:System.Threading.Tasks.TaskCreationOptions">
            <summary>
            Specifies flags that control optional behavior for the creation and execution of tasks.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.None">
            <summary>Specifies that default behavior should be used.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.SuppressExecutionContextFlow">
            <summary>Specifies that a task will not be executed under the execution context present when the
            task is started.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.RespectCreatorCancellation">
            <summary>Specifies that a task inherits cancellation from its parent.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.SelfReplicating">
            <summary>Specifies that a task will self-replicate as processors become available.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.Detached">
            <summary>Specifies that a task is not attached to a parent in the task hierarchy.</summary>
        </member>
        <member name="T:System.Threading.Tasks.InternalTaskOptions">
            <summary>
            Task creation flags which are only used internally.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.InternalOptionsMask">
            <summary>Used to filter out internal vs. public task creation options.</summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.StructuredTask">
            <summary>Specifies whether the task is created for a structured primitive.</summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskContinuationKind">
            <summary>
            The kind of continuation being scheduled.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationKind.OnCompletedSuccessfully">
            <summary>The continuation is scheduled when a task runs to completion without
            exception.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationKind.OnFailed">
            <summary>The continuation is scheduled when a task completes due to an exception.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationKind.OnAborted">
            <summary>The continuation is scheduled when a task is canceled before it begins
            execution.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationKind.OnAny">
            <summary>The continuation is scheduled when a task completes, regardless of the
            circumstances.</summary>
        </member>
        <member name="T:System.Threading.CooperativeEventSlim">
             <summary>
             CooperativeEventSlim wraps a CooperativeEvent internally with a little bit of
             spinning. When an event will be set imminently, it is often advantageous to avoid
             a 4k+ cycle context switch in favor of briefly spinning. Therefore we layer on to
             a brief amount of spinning that should, on the average, make using the slim event
             cheaper than using Win32 events directly. This can be reset manually, much like
             a Win32 manual-reset would be.
            
             Notes:
                 We lazily allocate the Win32 event internally. Therefore, the caller should
                 always call Dispose to clean it up, just in case. This API is a no-op of the
                 event wasn't allocated, but if it was, ensures that the event goes away
                 eagerly, instead of waiting for finalization.
             </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.#ctor">
            <summary>
            Constructs a new unset event object with a default spin count.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.#ctor(System.Boolean)">
            <summary>
            Constructs a new event object with a default spin count.
            </summary>
            <param name="initialState">Whether the event should be initially set (true) or not (false).</param>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.#ctor(System.Boolean,System.Int32)">
            <summary>
            Constructs a new event object.
            </summary>
            <param name="initialState">Whether the event should be initially set (true) or not (false).</param>
            <param name="spinCount">The number of spins before falling back to a true wait.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the spinCount is less than 0.</exception>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Initialize(System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Initializes the internal state of the event.
            </summary>
            <param name="initialState">Whether the event is set initially or not.</param>
            <param name="spinCount">The spin count that decides when the event will block.</param>
            <param name="useDynamicSpinAdjustment">Whether to use dynamic spin count adjustment.</param>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.ThrowIfDisposed">
            <summary>
            Throws an exception if the object has been disposed.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.LazyInitializeEvent">
            <summary>
            This method lazily initializes the event object. It uses CAS to guarantee that
            many threads racing to call this at once don't result in more than one event
            being stored and used. The event will be signaled or unsignaled depending on
            the state of the thin-event itself, with synchronization taken into account.
            </summary>
            <returns>True if a new event was created and stored, false otherwise.</returns>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Set">
            <summary>
            Sets the event, possibly waking up any waiting threads.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.InternalSetNoDisposeCheck">
            <summary>
            Sets the event, possibly waking up any waiting threads.  This particular method is
            used only by internal code that wishes to skip the dispose check.  The event is written
            to tolerate having been disposed, and in certain cases a caller knows the benign race
            conditions involved in waiting and setting are safe.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Reset">
            <summary>
            Resets the event to the unsignaled state.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Wait">
            <summary>
            Waits for the event to become set. We will spin briefly if the event isn't set
            (assuming a non-0 timeout), before falling back to a true wait.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Wait(System.TimeSpan)">
            <summary>
            Waits for the event to become set. We will spin briefly if the event isn't set
            (assuming a non-0 timeout), before falling back to a true wait.
            </summary>
            <param name="timeout">The maximum amount of time to wait.</param>
            <returns>True if the wait succeeded, false if the timeout expired.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the timeout is not within range.</exception>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Wait(System.Int32)">
            <summary>
            Waits for the event to become set. We will spin briefly if the event isn't set
            (assuming a non-0 timeout), before falling back to a true wait.
            </summary>
            <param name="millisecondsTimeout">The maximum amount of time to wait.</param>
            <returns>True if the wait succeeded, false if the timeout expired.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the timeout is not within range.</exception>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Dispose">
            <summary>
            Gets rid of the internal Win32 event, if one got allocated.
            </summary>
        </member>
        <member name="M:System.Threading.CooperativeEventSlim.Dispose(System.Boolean)">
            <summary>
            Disposes of internal state.
            </summary>
            <param name="disposing">Whether called for dispose (true) or finalization (false).</param>
        </member>
        <member name="P:System.Threading.CooperativeEventSlim.IsSet">
            <summary>
            Whether the event has been signaled.
            </summary>
        </member>
        <member name="P:System.Threading.CooperativeEventSlim.UnderlyingEvent">
            <summary>
            Retrieves the underlying CooperativeEvent object. Accessing this property forces
            initialization if the event hasn't been created already.
            </summary>
        </member>
        <member name="P:System.Threading.CooperativeEventSlim.UseDynamicSpinAdjustment">
            <summary>
            Whether we should use dynamic spin count adjustment.
            </summary>
        </member>
        <member name="P:System.Threading.CooperativeEventSlim.SpinCount">
            <summary>
            Retrieves the current spin count.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Future`1">
            <summary>
            Represents a <see cref="T:System.Threading.Tasks.Task"/> which produces a value at some time in the
            future.
            </summary>
            <typeparam name="T">The type of the value assocatied with this <see
            cref="T:System.Threading.Tasks.Future{T}"/>.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.#ctor(System.Func{`0},System.Threading.Tasks.Task,System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a new future object.
            </summary>
            <param name="parent">The parent task for this future.</param>
            <param name="valueSelector">A function that yields the future value.</param>
            <param name="taskManager">The task manager which will be used to execute the future.</param>
            <param name="options">Options to control the future's behavior.</param>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.Create">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The
            <see cref="T:System.Threading.Tasks.Future{T}"/> is not associated with a <see
            cref="T:System.Func{T}"/> and will only be complete when its value is explicitly set.
            </summary>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.Create(System.Func{`0})">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result
            of the function when the function has completed asynchronous execution.
            </summary>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> and will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.Create(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result
            of the function when the function has completed asynchronous execution.
            </summary>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.Create(System.Func{`0},System.Threading.Tasks.TaskManager)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result
            of the function when the function has completed asynchronous execution.
            </summary>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.Create(System.Func{`0},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result
            of the function when the function has completed asynchronous execution.
            </summary>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.Tasks.Future`1.InvokeFuture``1(System.Object)" -->
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith(System.Action{System.Threading.Tasks.Future{`0}})">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith(System.Action{System.Threading.Tasks.Future{`0}},System.Threading.Tasks.TaskContinuationKind)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith(System.Action{System.Threading.Tasks.Future{`0}},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Task"/>.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith(System.Action{System.Threading.Tasks.Future{`0}},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="action">An action to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Task"/>.</param>
            <param name="executeSynchronously">Whether to run the continuation synchronously.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for
            execution until the current task has completed. If the criteria specified through the <paramref
            name="kind"/> parameter is not met, the continuation task will be canceled instead of
            activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith``1(System.Func{System.Threading.Tasks.Future{`0},``0})">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="func">A function to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Future{T}"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Future{T}"/> will not be scheduled for
            execution until the current <see cref="T:System.Threading.Tasks.Future{T}"/> has
            completed.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="func"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith``1(System.Func{System.Threading.Tasks.Future{`0},``0},System.Threading.Tasks.TaskContinuationKind)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="func">A function to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Future{T}"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Future{T}"/> will not be scheduled for
            execution until the current <see cref="T:System.Threading.Tasks.Future{T}"/> has completed. If
            the criteria specified through the <paramref name="kind"/> parameter is not met, the continuation
            <see cref="T:System.Threading.Tasks.Future{T}"/> will be canceled instead of activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="func"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith``1(System.Func{System.Threading.Tasks.Future{`0},``0},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="func">A function to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Future{T}"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Future{T}"/> will not be scheduled for
            execution until the current <see cref="T:System.Threading.Tasks.Future{T}"/> has completed. If
            the criteria specified through the <paramref name="kind"/> parameter is not met, the continuation
            <see cref="T:System.Threading.Tasks.Future{T}"/> will be canceled instead of activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="func"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future`1.ContinueWith``1(System.Func{System.Threading.Tasks.Future{`0},``0},System.Threading.Tasks.TaskContinuationKind,System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
            <summary>
            Creates a continuation that executes when the target <see
            cref="T:System.Threading.Tasks.Future{T}"/>
            completes.
            </summary>
            <param name="func">A function to run when the <see cref="T:System.Threading.Tasks.Future{T}"/>
            completes.</param>
            <param name="kind">Restrictions on when the continuation is activated.</param>
            <param name="options">Options that control the behavior of the created <see
            cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <param name="executeSynchronously">Whether to run the continuation synchronously.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Future{T}"/>.</returns>
            <remarks>The returned <see cref="T:System.Threading.Tasks.Future{T}"/> will not be scheduled for
            execution until the current <see cref="T:System.Threading.Tasks.Future{T}"/> has completed. If
            the criteria specified through the <paramref name="kind"/> parameter is not met, the continuation
            <see cref="T:System.Threading.Tasks.Future{T}"/> will be canceled instead of activated.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="func"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="kind"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationKind"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="P:System.Threading.Tasks.Future`1.Value">
            <summary>
            Gets or sets the value of this <see cref="T:System.Threading.Tasks.Future{T}"/>.
            </summary>
            <remarks>
            The get accessor for this property calls <see cref="M:System.Threading.Tasks.Task.Wait"/> to ensure the asynchronous computation is
            complete before returning. Once the result of the computation is available, it is stored and will
            be returned immediately on later calls to <see cref="P:System.Threading.Tasks.Future`1.Value"/>. If the <see cref="T:System.Threading.Tasks.Future{T}"/> was provided with a <see cref="T:System.Func{T}"/>
            when created, the <see cref="P:System.Threading.Tasks.Future`1.Value"/> property can only be set internally by the <see cref="T:System.Threading.Tasks.Future{T}"/>, any attempts to set it manually will result in an
            exception. Conversely, a <see cref="T:System.Threading.Tasks.Future{T}"/> created without a <see cref="T:System.Func{T}"/> can only be set manually, and it can only be set once. Attempting to
            set such an instance's <see cref="P:System.Threading.Tasks.Future`1.Value"/> property multiple times will result in an exception.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Future`1.Exception">
            <summary>
            Gets or sets the <see cref="T:System.Exception"/> that caused the execution of the <see cref="T:System.Threading.Tasks.Future{T}"/> to end prematurely.
            </summary>
            <remarks>
            The set accessor may only be used to set the <see cref="P:System.Threading.Tasks.Future`1.Exception"/> property if the
            <see cref="T:System.Threading.Tasks.Future{T}"/> instance was created without a <see cref="T:System.Func{T}"/>. Attempting to set <see cref="P:System.Threading.Tasks.Future`1.Exception"/> for a <see cref="T:System.Threading.Tasks.Future{T}"/> created with a <see cref="T:System.Func{T}"/>
            will result in an exception.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.Future">
            <summary>
            A factory class used to create instances of <see cref="T:System.Threading.Tasks.Future{T}"/>.
            </summary>
            <remarks>
            <see cref="T:System.Threading.Tasks.Future{T}"/> provides Create methods as does <see cref="T:System.Threading.Tasks.Future"/>. However, <see cref="T:System.Threading.Tasks.Future"/>
            supports type inferencing in languages like C#. For example, with <see cref="T:System.Threading.Tasks.Future"/> it is possible to write:
            <code>var f = Future.Create(() =&gt; g());</code>
            The C# compiler will infer the type argument to the <see cref="M:System.Threading.Tasks.Future.Create``1(System.Func{``0})"/> factory
            method by inspecting the return value of the method g. It cannot do this for type parameters for
            types.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Future.Create``1">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The
            <see cref="T:System.Threading.Tasks.Future{T}"/> is not associated with a <see
            cref="T:System.Func{T}"/> and will only be complete when its value is explicitly set.
            </summary>
            <typeparam name="T">The type of the value associated with the <see
            cref="T:System.Threading.Tasks.Future{T}"/> to create.</typeparam>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Future.Create``1(System.Func{``0})">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result of the function when
            the function has completed asynchronous execution.
            </summary>
            <typeparam name="T">The type of the value associated with the <see cref="T:System.Threading.Tasks.Future{T}"/> to create.</typeparam>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> and will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future.Create``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result of the function when
            the function has completed asynchronous execution.
            </summary>
            <typeparam name="T">The type of the value associated with the <see cref="T:System.Threading.Tasks.Future{T}"/> to create.</typeparam>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be run on the default <see cref="T:System.Threading.Tasks.TaskManager"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future.Create``1(System.Func{``0},System.Threading.Tasks.TaskManager)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result of the function when
            the function has completed asynchronous execution.
            </summary>
            <typeparam name="T">The type of the value associated with the <see cref="T:System.Threading.Tasks.Future{T}"/> to create.</typeparam>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <remarks>The <see cref="T:System.Threading.Tasks.Future{T}"/> will be created with the default
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Future.Create``1(System.Func{``0},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a new <see cref="T:System.Threading.Tasks.Future{T}"/> object. The <see cref="T:System.Threading.Tasks.Future{T}"/> is associated with the provided
            <see cref="T:System.Func{T}"/> and will have its <see cref="P:System.Threading.Tasks.Future`1.Value"/> property set to the result of the function when
            the function has completed asynchronous execution.
            </summary>
            <typeparam name="T">The type of the value associated with the <see cref="T:System.Threading.Tasks.Future{T}"/> to create.</typeparam>
            <param name="valueSelector">A <see cref="T:System.Func{T}"/> that yields the future
            value.</param>
            <param name="taskManager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use to run
            the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <param name="options">Options that control the behavior of the created <see cref="T:System.Threading.Tasks.Future{T}"/>.</param>
            <returns>A new <see cref="T:System.Threading.Tasks.Future{T}"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="valueSelector"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="taskManager"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
        </member>
        <member name="T:System.Threading.Parallel">
            <summary>
            Provides support for parallel loops and regions.
            </summary>
        </member>
        <member name="M:System.Threading.Parallel.Invoke(System.Action[])">
            <summary>
            Executes each of the provided actions inside a discrete, asynchronous task.
            </summary>
            <param name="actions">An array of actions to execute.</param>
            <remarks>
            The method does not return until each of the provided actions has completed, regardless of
            whether completion occurs due to normal or exceptional termination.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="actions"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="actions"/> array contains a null
            element.</exception>
            <exception cref="T:System.Threading.AggregateException">An action threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.Invoke(System.Action[],System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Executes each of the provided actions inside a discrete, asynchronous task.
            </summary>
            <param name="actions">An array of actions to execute.</param>
            <param name="manager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use for
            execution.</param>
            <param name="options">The <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> to use for
            creating <see cref="T:System.Threading.Tasks.Task"/> instances in support of this method.</param>
            <remarks>
            The method does not return until each of the provided actions has completed, regardless of
            whether completion occurs due to normal or exceptional termination.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="actions"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="actions"/> array contains a null
            element.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="manager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
            <exception cref="T:System.Threading.AggregateException">An action threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see
            cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref
            name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For(System.Int32,System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="step">The amount by which the index will be incremented after each
            iteration.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="step"/> argument must
            be positive.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see
            cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <remarks>
            The body delegate is provided with the iteration value as an argument.
            </remarks>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref
            name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.ParallelState})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState"/> instance which may be used to stop the loop before
            all iterations have completed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For(System.Int32,System.Int32,System.Int32,System.Action{System.Int32,System.Threading.ParallelState})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="step">The amount by which the index will be incremented after each
            iteration.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState"/> instance which may be used to stop the loop before
            all iterations have completed.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="step"/> argument must
            be positive.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Action{System.Int32,System.Threading.ParallelState{``0}})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/> or the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Action{System.Int32,System.Threading.ParallelState{``0}},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <param name="threadLocalFinally">An action that cleans up the thread-local data.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalFinally"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/>, the <paramref name="body"/>, or the <paramref name="threadLocalFinally"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For``1(System.Int32,System.Int32,System.Int32,System.Func{``0},System.Action{System.Int32,System.Threading.ParallelState{``0}})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="step">The amount by which the index will be incremented after each
            iteration.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="step"/> argument must
            be positive.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/> or the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For``1(System.Int32,System.Int32,System.Int32,System.Func{``0},System.Action{System.Int32,System.Threading.ParallelState{``0}},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="step">The amount by which the index will be incremented after each
            iteration.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <param name="threadLocalFinally">An action that cleans up the thread-local data.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="step"/> argument must
            be positive.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalFinally"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/>, the <paramref name="body"/>, or the <paramref name="threadLocalFinally"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.For``1(System.Int32,System.Int32,System.Int32,System.Func{``0},System.Action{System.Int32,System.Threading.ParallelState{``0}},System.Action{``0},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="step">The amount by which the index will be incremented after each
            iteration.</param>
            <param name="body">The body to be invoked for each iteration.</param>
            <param name="threadLocalFinally">An action that cleans up the thread-local data.</param>
            <param name="manager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use for
            execution.</param>
            <param name="options">The <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> to use for
            creating <see cref="T:System.Threading.Tasks.Task"/> instances in support of this method.</param>
            <remarks>
            The body delegate is provided with the iteration value as an argument as well as with a
            <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="step"/> argument must
            be positive.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalFinally"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="manager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/>, the <paramref name="body"/>, or the <paramref name="threadLocalFinally"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForWorker``1(System.Int32,System.Int32,System.Int32,System.Action{System.Int32},System.Action{System.Int32,System.Threading.ParallelState},System.Action{System.Int32,System.Threading.ParallelState{``0}},System.Func{``0},System.Action{``0},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Performs the major work of the parallel for loop. It assumes that argument validation has already
            been performed by the caller. This function's whole purpose in life is to enable as much reuse of
            common implementation details for the various For overloads we offer. Without it, we'd end up
            with lots of duplicate code. It handles: (1) simple for loops, (2) for loops that depend on
            ParallelState, and (3) for loops with thread local data.
            
            @TODO: at some point in the future, we may want to manually inline the interesting bits into the
            specific overloads above. There is some overhead associated with the extra arguments passed to
            the function, and various if-checks in the code. It is also more difficult to follow what the
            code does as-is because it has to handle the three flavors.
            </summary>
            <typeparam name="TLocal">The type of the local data.</typeparam>
            <param name="fromInclusive">The loop's start index, inclusive.</param>
            <param name="toExclusive">The loop's end index, exclusive.</param>
            <param name="step">The amount by which the loop index is advanced each iteration.</param>
            <param name="body">The simple loop body.</param>
            <param name="bodyWithState">The loop body for ParallelState overloads.</param>
            <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
            <param name="threadLocalInit">A selector function that returns new thread local state.</param>
            <param name="threadLocalFinally">A cleanup function to destroy thread local state.</param>
            <param name="manager">The manager to execute the for loop within.</param>
            <param name="options">Options to control task behavior.</param>
            <remarks>Only one of the body arguments may be supplied (i.e. they are exclusive).</remarks>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of the data in the enumerable.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">The action to invoke for each element in the <paramref
            name="source"/>.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see
            cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref
            name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.ParallelState})">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of data in the source.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">The action to invoke for each element in the <paramref name="source"/>.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated as
            well as with a
            <see cref="T:System.Threading.ParallelState"/> instance which may be used to stop the loop before
            all iterations have completed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32,System.Threading.ParallelState})">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of data in the source.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">The action to invoke for each element in the <paramref name="source"/>.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated as
            well as with the index of the item as it was taken from the enumerable and a <see cref="T:System.Threading.ParallelState"/> instance which may be used to stop the loop before all
            iterations have completed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}})">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of data in the source.</typeparam>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="body">The action to invoke for each element in the <paramref name="source"/>.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated as
            well as with the index of the item as it was taken from the enumerable and a <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/> or the <paramref name="body"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}},System.Action{``1})">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of data in the source.</typeparam>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="body">The action to invoke for each element in the <paramref name="source"/>.</param>
            <param name="threadLocalFinally">An action that cleans up the thread-local data.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated as
            well as with the index of the item as it was taken from the enumerable and a <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalFinally"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/>, the <paramref name="body"/>, or the <paramref name="threadLocalFinally"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}},System.Action{``1},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Executes an action for each item in the enumerable data source, where each element may
            potentially be processed in parallel.
            </summary>
            <typeparam name="TSource">The type of data in the source.</typeparam>
            <typeparam name="TLocal">The type of thread-local data that will be used.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="threadLocalInit">A function that generates thread-local data. This data is
            provided to the body through a <see cref="T:System.Threading.ParallelState`1"/>
            instance.</param>
            <param name="body">The action to invoke for each element in the <paramref name="source"/>.</param>
            <param name="threadLocalFinally">An action that cleans up the thread-local data.</param>
            <param name="manager">The <see cref="T:System.Threading.Tasks.TaskManager"/> to use for
            execution.</param>
            <param name="options">The <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> to use for
            creating <see cref="T:System.Threading.Tasks.Task"/> instances in support of this method.</param>
            <remarks>
            The body delegate is provided with the item from <paramref name="source"/> being enumerated as
            well as with the index of the item as it was taken from the enumerable and a <see cref="T:System.Threading.ParallelState`1"/> instance which may be used to stop the loop
            before all iterations have completed. It may also be used to store per-thread data to avoid
            synchronization overhead in the loop body.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="source"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalInit"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="threadLocalFinally"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="manager"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified <see cref="T:System.Threading.Tasks.TaskManager"/>
            has been shutdown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options"/> argument
            specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions"/>.</exception>
            <exception cref="T:System.Threading.AggregateException">At least one invocation of the <paramref name="threadLocalInit"/>, the <paramref name="body"/>, or the <paramref name="threadLocalFinally"/> threw an exception.</exception>
        </member>
        <member name="M:System.Threading.Parallel.GrabChunkFromIEnumerable``1(System.Collections.Generic.IEnumerator{``0},``0[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Utility function to be used by ForEachWorker. Copies up to maxElementsToTake elements
            from the IEnumerator into an localArray, returns number of elements copied. 
            SharedIndex and currentBaseIndex need to be passed in by reference, 
            because their update must happen under lock(sharedEnumerator)
            </summary>
        </member>
        <member name="M:System.Threading.Parallel.ForEachWorker``2(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Threading.ParallelState},System.Action{``0,System.Int32},System.Action{``0,System.Int32,System.Threading.ParallelState},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}},System.Func{``1},System.Action{``1},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Performs the major work of the parallel foreach loop. It assumes that argument validation has
            already been performed by the caller. This function's whole purpose in life is to enable as much
            reuse of common implementation details for the various For overloads we offer. Without it, we'd
            end up with lots of duplicate code. It handles: (1) simple foreach loops, (2) foreach loops that
            depend on ParallelState, and (3) foreach loops that access indices, (4) foreach loops with thread
            local data, and any necessary permutations thereof.
            
            @TODO: at some point in the future, we may want to manually inline the interesting bits into the
            specific overloads above. There is some overhead associated with the extra arguments passed to
            the function, and various if-checks in the code. It is also more difficult to follow what the
            code does as-is because it has to handle the all flavors.
            </summary>
            <typeparam name="TSource">The type of the source data.</typeparam>
            <typeparam name="TLocal">The type of the local data.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">The simple loop body.</param>
            <param name="bodyWithState">The loop body for ParallelState overloads.</param>
            <param name="bodyWithIndex">The loop body for indexed overloads.</param>
            <param name="bodyWithIndexAndState">The loop body for indexed/ParallelState overloads.</param>
            <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
            <param name="threadLocalInit">A selector function that returns new thread local state.</param>
            <param name="threadLocalFinally">A cleanup function to destroy thread local state.</param>
            <param name="manager">The task manager into which work will be queued.</param>
            <param name="options">Options to control task behavior.</param>
            <remarks>Only one of the bodyXX arguments may be supplied (i.e. they are exclusive).</remarks>
        </member>
        <member name="M:System.Threading.Parallel.ForEachWorker``2(``0[],System.Action{``0},System.Action{``0,System.Threading.ParallelState},System.Action{``0,System.Int32},System.Action{``0,System.Int32,System.Threading.ParallelState},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}},System.Func{``1},System.Action{``1},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            A fast path for the more general ForEachWorker method above. This uses ldelem instructions to
            access the individual elements of the array, which will be faster.
            </summary>
            <typeparam name="TSource">The type of the source data.</typeparam>
            <typeparam name="TLocal">The type of the local data.</typeparam>
            <param name="array">An array data source.</param>
            <param name="body">The simple loop body.</param>
            <param name="bodyWithState">The loop body for ParallelState overloads.</param>
            <param name="bodyWithIndex">The loop body for indexed overloads.</param>
            <param name="bodyWithIndexAndState">The loop body for indexed/ParallelState overloads.</param>
            <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
            <param name="threadLocalInit">A selector function that returns new thread local state.</param>
            <param name="threadLocalFinally">A cleanup function to destroy thread local state.</param>
            <param name="manager">The manager to execute the for loop within.</param>
            <param name="options">Options to control task behavior.</param>
        </member>
        <member name="M:System.Threading.Parallel.ForEachWorker``2(System.Collections.Generic.IList{``0},System.Action{``0},System.Action{``0,System.Threading.ParallelState},System.Action{``0,System.Int32},System.Action{``0,System.Int32,System.Threading.ParallelState},System.Action{``0,System.Int32,System.Threading.ParallelState{``1}},System.Func{``1},System.Action{``1},System.Threading.Tasks.TaskManager,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            A fast path for the more general ForEachWorker method above. This uses IList&lt;T&gt;'s indexer
            capabilities to access the individual elements of the list rather than an enumerator.
            </summary>
            <typeparam name="TSource">The type of the source data.</typeparam>
            <typeparam name="TLocal">The type of the local data.</typeparam>
            <param name="list">A list data source.</param>
            <param name="body">The simple loop body.</param>
            <param name="bodyWithState">The loop body for ParallelState overloads.</param>
            <param name="bodyWithIndex">The loop body for indexed overloads.</param>
            <param name="bodyWithIndexAndState">The loop body for indexed/ParallelState overloads.</param>
            <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
            <param name="threadLocalInit">A selector function that returns new thread local state.</param>
            <param name="threadLocalFinally">A cleanup function to destroy thread local state.</param>
            <param name="manager">The task manager into which work will be queued.</param>
            <param name="options">Options to control task behavior.</param>
        </member>
        <member name="T:System.Threading.ParallelState">
            <summary>
            Allows independent iterations of a parallel loop to interact with other iterations.
            </summary>
        </member>
        <member name="M:System.Threading.ParallelState.#ctor(System.Threading.ParallelStateFlags)">
            <summary>
            Internal constructor to ensure an instance isn't created by users.
            </summary>
            <param name="sharedParallelStateFlags">A flag shared among all threads participating
            in the execution of a certain loop.</param>
        </member>
        <member name="M:System.Threading.ParallelState.Stop">
            <summary>
            Communicates that the parallel loop should be stopped at the system's earliest convenience.
            </summary>
            <remarks>
            This is shared with all other concurrent threads in the system which are participating in the
            loop's execution. After calling <see cref="M:System.Threading.ParallelState.Stop"/>, no additional iterations will be executed on
            the current thread.
            </remarks>
        </member>
        <member name="P:System.Threading.ParallelState.IsStopped">
            <summary>
            Gets whether a request has been issued to stop the loop.
            </summary>
        </member>
        <member name="T:System.Threading.ParallelStateFlags">
            <summary>
            An internal class used to share a single boolean.
            </summary>
        </member>
        <member name="T:System.Threading.ParallelState`1">
            <summary>
            Extends the base <see cref="T:System.Threading.ParallelState"/> class with a place-holder for
            thread-local state.
            </summary>
            <remarks>This type does not enforce the thread-local state's isolation, but that is its intended
            usage and purpose, hence the naming.</remarks>
            <typeparam name="TLocal">The type of the thread-local state.</typeparam>
        </member>
        <member name="M:System.Threading.ParallelState`1.#ctor(System.Threading.ParallelStateFlags,`0)">
            <summary>
            Internal constructor to ensure an instance isn't created by users.
            </summary>
            <param name="sharedParallelStateFlags">A flag shared among all threads participating
            in the execution of a certain loop.</param>
            <param name="threadLocalState">The state local to a single thread.</param>
        </member>
        <member name="P:System.Threading.ParallelState`1.ThreadLocalState">
            <summary>
            Gets the thread-local state for this <see cref="T:System.Threading.ParallelState"/> instance.
            </summary>
        </member>
        <member name="T:System.Linq.IParallelEnumerable">
            <summary>
            Instances of this interface bind to Parallel LINQ extension methods to execute
            in parallel. See IEnumerable.
            </summary>
        </member>
        <member name="T:System.Linq.IParallelEnumerable`1">
            <summary>
            Instances of this interface bind to Parallel LINQ extension methods to execute
            in parallel. See IEnumerable.
            </summary>
        </member>
        <member name="M:System.Linq.IParallelEnumerable`1.GetEnumerator(System.Boolean)">
            <summary>
            Overload that allows developers to request or supress pipelining explicitly. 
            The default behaviour if not using this overload is to use pipelining.  Use
            pipelining when following a query with foreach to execute the foreach on a
            separate thread as the query when elements become available. Supressing pipelining
            will force the system to use all available resources processing the query to
            completion before executing the foreach loop.
            </summary>
            <param name="usePipelining">Set to true to request pipelining.</param>
            <returns>An IEnumerator that turns on pipelining in parallel execution.</returns>
        </member>
        <member name="T:System.Linq.IParallelOrderedEnumerable`1">
            <summary>
            The return type of Parallel LINQ sorting methods. See IOrderedEnumerable.
            </summary>
        </member>
        <member name="T:System.Linq.ParallelQuery">
            <summary>
            This class adds static extension methods to IEnumerable to faciliate using
            Parallel LINQ to Objects with LINQ to objects. Primarily, this class adds
            AsParallel() methods which convert IEnumerable to IParallelEnumerable and
            an AsSequential() method to convert IParallelEnumerable to IEnumerable.
            </summary>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsParallel``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            This is the method to opt into Parallel LINQ. This method takes no parameters 
            and would set the existing parameters to default. This will not preserve the input 
            order in the output and will use the maximum available hardware threads.
            </summary>
            <typeparam name="T">The type of elements of source.</typeparam>
            <param name="source">An IEnumerable to convert to an IParallelEnumerable.</param>
            <returns>The source as an IParallelEnumerable to bind to
            ParallelEnumerable extension methods.</returns>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsParallel``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            This is the method to opt into Parallel LINQ. This method takes a degree of
            parallelism parameter to override the default.
            </summary>
            <typeparam name="T">The type of elements of source.</typeparam>
            <param name="source">An IEnumerable to convert to an IParallelEnumerable.</param>
            <param name="degreeOfParallelism">(DOP) Specified the number of threads to use in the query.</param>
            <returns>The source as an IParallelEnumerable to bind to
            ParallelEnumerable extension methods.</returns>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsOrdered``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            AsOrdered is a method that tells PLINQ to treat a data source as if it was ordered, overriding the unordered default.
            AsOrdered may only be invoked on sequences returned by AsParallel, ParallelEnumerable.Range,
            and ParallelEnumerable.Repeat.
            </summary>
            <typeparam name="T">The type of elements of source.</typeparam>
            <param name="source">The input sequence.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown is the source is not one of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.
            </exception>
            <remarks>
            A natural tension exists between performance and preserving order in parallel processing. By default, 
            PLINQ behaves as if the ordering of the results is arbitrary unless there is an explicit OrderBy operator in the query.
            </remarks>
            <returns>The source sequence which will maintain ordering in the query.</returns>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsUnordered``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            AsUnordered tells PLINQ that it should treat a particular intermediate result as if no
            order was implied among the elements. The user may use the AsUnordered method to obtain
            performance benefits when ordering is not required in a part of the query.
            </summary>
            <typeparam name="T">The type of elements of source.</typeparam>
            <param name="source">The input sequence.</param>
            <returns>The source sequence with arbitrary order.</returns>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsParallel(System.Collections.IEnumerable)">
            <summary>
            This is the method to opt into Parallel LINQ. This method provide overloads to non-generic
            IEnumerables.
            </summary>
            <param name="source">An IEnumerable to convert to an IParallelEnumerable.</param>
            <returns>
            The source as an IParallelEnumerable to bind to
            ParallelEnumerable extension methods.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelQuery.AsSequential``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Converts an IParallelEnumerable into an IEnumerable, to force sequential
            evaluation of the query.  See the Parallel Blockers topic for when to use this.
            </summary>
            <typeparam name="T">The type of elements of source.</typeparam>
            <param name="source">An IParallelEnumerable to convert to an IEnumerable.</param>
            <returns>The source as an IEnumerable to bind tosequential extension methods.</returns>
        </member>
        <member name="T:System.Linq.ParallelEnumerable">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for querying objects that implement 
            IParallelEnumerable&lt;(Of &lt;(T&gt;)&gt;).  This is the Parallel equivalent of 
            <see cref="T:System.Linq.Enumerable"/>.
            </summary>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.IParallelEnumerable{``0},System.Action{``0})">
            <summary>
            Parallelizes output by calling action for each element in the source.  This is 
            an efficient way to process the output from PLINQ because it does not require a 
            merge step at the end.  However, order of execution is nondeterministic.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source">The IParallelEnumerable whose elements will be processed by 
            action.</param>
            <param name="action">An action to call on each element.</param>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Range. 
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count">The number of sequential integers to generate.</param>
            <returns>An <b>IEnumerable&lt;Int32&gt;</b> in C# or <B>IEnumerable(Of Int32)</B> in 
            Visual Basic that contains a range of sequential integral numbers.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Range().
            </summary>
            <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
            <param name="element">The value to be repeated.</param>
            <param name="count">The number of times to repeat the value in the generated sequence.</param>
            <returns>A sequence that contains a repeated value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Empty``1">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Empty().
            </summary>
            <typeparam name="TResult">The type to assign to the type parameter of the returned 
            generic sequence.</typeparam>
            <returns>An empty sequence whose type argument is <B>TResult</B>.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Where().
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A sequence that contains elements from the input sequence that satisfy 
            the condition.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Where().
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A sequence that contains elements from the input sequence that satisfy the condition.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Select().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TResult">The type of elements resturned by <b>selector</b>.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>A sequence whose elements are the result of invoking the transform function on each 
            element of <B>source</B>.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Select().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TResult">The type of elements resturned by <b>selector</b>.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>A sequence whose elements are the result of invoking the transform function on each 
            element of <B>source</B>.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            This method combines the sequences first and second pairwise with the resultSelector Func.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TResult">The type of the return elements.</typeparam>
            <param name="first">The first sequence to zip.</param>
            <param name="second">The second sequence to zip.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>
            A sequence that has elements of type <B>TResult</B> that are obtained by performing 
            resultSelector pairwise on two sequences. If the sequence lengths are unequal, this truncates
            to the length of the shorter sequence.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Join().
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of 
            the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of 
            the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>A sequence that has elements of type <B>TResult</B> that are obtained by performing 
            an inner join on two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Join().
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to hash and compare keys.</param>
            <returns>A sequence that has elements of type <B>TResult</B> that are obtained by performing 
            an inner join on two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupJoin().
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>A sequence that has elements of type <B>TResult</B> that are obtained by performing 
            a grouped join on two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupJoin().
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to hash and compare keys.</param>
            <returns>A sequence that has elements of type <B>TResult</B> that are obtained by performing 
            a grouped join on two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SelectMany().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by <B>selector</B>.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function on each element of the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SelectMany().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by <B>selector</B>.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function on each element of the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SelectMany(). This is an 
            overload that is not present on Enumerable. This provides a performance 
            improvement over the method that takes a collectionSelector.  It should be used 
            where the flexibility of collectionSelector is not needed.  
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TCollection">The type of elements of <b>collection</b>.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by 
            <B>resultSelector</B>.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collection">The second sequence to be applied with the <B>source</B>.</param>
            <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>A sequence whose elements are the result of mapping each of the <B>collection</B> 
            elements and their corresponding <B>source</B> element to a <B>result</B> element.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SelectMany().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by <b>collectionSelector</b>.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each source element; 
            the second parameter of the function represents the index of the source element.</param>
            <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function <B>collectionSelector</B> on each element of <B>source</B> and then mapping 
            each of those sequence elements and their corresponding source element to a result element.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SelectMany().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by 
            <b>collectionSelector</b>.</typeparam>
            <typeparam name="TResult">The type of elements to return.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each source element; 
            the second parameter of the function represents the index of the source element.</param>
            <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>
            A sequence whose elements are the result of invoking the one-to-many transform 
            function <B>collectionSelector</B> on each element of <B>source</B> and then mapping 
            each of those sequence elements and their corresponding source element to a 
            result element.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.OrderBy().
            </summary>
            <remarks>
            This is not a stable sort. To achieve a stable sort, change:
            <code>var ordered = source.OrderBy((e) => e.k);</code>
            to:
            <code>var ordered = source.Select((e,i) => new { E=e, I=i }).OrderBy((v) => v.i).Select((v) => v.e);</code>
            </remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.OrderBy().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted according 
            to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.OrderByDescending().
            </summary>
            <remarks>
            This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the 
            workaround.
            </remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            descending according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.OrderByDescending().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted descending 
            according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.IParallelOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ThenBy().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for 
            the workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than 
            contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are 
            sorted according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.IParallelOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ThenBy().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the 
            workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.IParallelOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ThenByDescending().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the 
            workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            descending according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.IParallelOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ThenByDescending().
            </summary>
            <remarks>This is not a stable sort, see OrderBy(IParallelEnumberable, Func) for the 
            workaround.</remarks>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            descending according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            descending according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) whose elements are sorted 
            descending according to a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <typeparam name="TElement">The type of the elements in the IGrouping</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="elementSelector">A function to map each source element to an element in an  IGrouping.</param>
            <returns>An IParallelEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or 
            IParallelEnumerable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each IGrouping 
            generic object contains a collection of objects of type <B>TElement</B> and a key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <b>keySelector</b>.</typeparam>
            <typeparam name="TElement">The type of the elements in the IGrouping</typeparam>
            <param name="source">An IOrderedEnumerable&lt;(Of &lt;(TElement&gt;)&gt;) than contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="elementSelector">A function to map each source element to an element in an  IGrouping.</param>
            <param name="comparer">An IComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>
            An IParallelEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or 
            IParallelEnumerable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each IGrouping 
            generic object contains a collection of objects of type <B>TElement</B> and a key.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <B>resultSelector</B>.</typeparam>
            <param name="source">A sequence whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A collection of elements of type <b>TResult</b> where each element represents a 
            projection over a group and its key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <B>resultSelector</B>.</typeparam>
            <param name="source">A sequence whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>
            An <B>IParallelEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</B> in C# or 
            <B>IParallelEnumerable(Of IGrouping(Of TKey, TElement))</B> in Visual Basic where each 
            IGrouping&lt;(Of &lt;(TKey, TElement&gt;)&gt;) object contains a collection of objects 
            of type <B>TElement</B> and a key.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the elements in each 
            IGrouping&lt;(Of &lt;(TKey, TElement&gt;)&gt;).</typeparam>
            <typeparam name="TResult">The type of the result value returned by <B>resultSelector</B>.</typeparam>
            <param name="source">A sequence whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in an 
            IGrouping&lt;TKey, TElement&gt;.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A collection of elements of type <B>TResult</B> where each element represents a 
            projection over a group and its key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.GroupBy().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the elements in each 
            IGrouping&lt;(Of &lt;(TKey, TElement&gt;)&gt;).</typeparam>
            <typeparam name="TResult">The type of the result value returned by <B>resultSelector</B>.</typeparam>
            <param name="source">A sequence whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in an 
            IGrouping&lt;TKey, TElement&gt;.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>A collection of elements of type <B>TResult</B> where each element represents a 
            projection over a group and its key.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,``0,``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Aggregate().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence to aggregate over.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <returns>The final accumulator value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.IParallelEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Aggregate().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <param name="source">A sequence to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <returns>The final accumulator value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.IParallelEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Aggregate().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">A sequence to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <param name="resultSelector">A function to transform the final accumulator value 
            into the result value.</param>
            <returns>The transformed final accumulator value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.IParallelEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Aggregate(). This is an overload not 
            present in the sequential version of LINQ to Objects.
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">A sequence to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="intermediateReduceFunc">
            An accumulator function to be invoked on each element in a partition.
            </param>
            <param name="finalReduceFunc">
            An accumulator function to be invoked to merge the yielded elements from each partition.
            </param>
            <param name="resultSelector">
            A function to transform the final accumulator value into the result value.
            </param>
            <returns>The transformed final accumulator value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.IParallelEnumerable{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Aggregate(). This is an overload not 
            present in the sequential version of LINQ to Objects.
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">A sequence to aggregate over.</param>
            <param name="seedFactory">
            A function that returns the initial accumulator value.
            </param>
            <param name="intermediateReduceFunction">
            An accumulator function to be invoked on each element in a partition.
            </param>
            <param name="finalReduceFunction">
            An accumulator function to be invoked to merge the yielded elements from each partition. 
            </param>
            <param name="resultSelector">
            A function to transform the final accumulator value into the result value.
            </param>
            <returns>The transformed final accumulator value.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Count().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Count().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A number that represents how many elements in the sequence satisfy the condition 
            in the predicate function.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.LongCount().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.LongCount().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A number that represents how many elements in the sequence satisfy the condition 
            in the predicate function.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.IParallelEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Sum().
            </summary>
            <param name="source">A sequence of values to calculate the sum of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.IParallelEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Min().
            </summary>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.IParallelEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Max().
            </summary>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.IParallelEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Average().
            </summary>
            <param name="source">A sequence of values that are used to calculate an average.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The average of the sequence of values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Any().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">An IEnumerable whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            true if any elements in the source sequence pass the test in the specified predicate; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Any().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The IEnumerable to check for emptiness.</param>
            <returns>true if the source sequence contains any elements; otherwise, false.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.All``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.All().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">A sequence whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            true if all elements in the source sequence pass the test in the specified predicate; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.IParallelEnumerable{``0},``0)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Contains().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">The value to locate in the sequence.</param>
            <returns>
            true if the source sequence contains an element that has the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.IParallelEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Contains().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">The value to locate in the sequence.</param>
            <param name="comparer">An equality comparer to compare values.</param>
            <returns>
            true if the source sequence contains an element that has the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.IParallelEnumerable{``0},System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Take().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="count">The number of elements to return.</param>
            <returns>
            A sequence that contains the specified number of elements from the start of the input sequence.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.TakeWhile().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A sequence that contains the elements from the input sequence that occur before 
            the element at which the test no longer passes.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.TakeWhile().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">
            A function to test each source element for a condition; the second parameter of the 
            function represents the index of the source element.
            </param>
            <returns>
            A sequence that contains elements from the input sequence that occur before 
            the element at which the test no longer passes.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.IParallelEnumerable{``0},System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Skip().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="count">The number of elements to skip before returning the remaining elements.</param>
            <returns>
            A sequence that contains the elements that occur after the specified index in the input sequence.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SkipWhile().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A sequence that contains the elements from the input sequence starting at 
            the first element in the linear series that does not pass the test specified by 
            <B>predicate</B>.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SkipWhile().
            </summary>
            <typeparam name="TSource">The type of elements of <b>source</b>.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">
            A function to test each source element for a condition; the 
            second parameter of the function represents the index of the source element.
            </param>
            <returns>
            A sequence that contains the elements from the input sequence starting at the 
            first element in the linear series that does not pass the test specified by 
            <B>predicate</B>.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Concat().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">The first sequence to concatenate.</param>
            <param name="second">The sequence to concatenate to the first sequence.</param>
            <returns>A sequence that contains the concatenated elements of the two input sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SequenceEqual().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence to compare to <b>second</b>.</param>
            <param name="second">A sequence to compare to the first input sequence.</param>
            <returns>
            true if the two source sequences are of equal length and their corresponding elements 
            are equal according to the default equality comparer for their type; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SequenceEqual().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence to compare to <b>second</b>.</param>
            <param name="second">A sequence to compare to the first input sequence.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to use to compare elements.</param>
            <returns>
            true if the two source sequences are of equal length and their corresponding 
            elements are equal according to the default equality comparer for their type; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Distinct().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <returns>A sequence that contains distinct elements from the source sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Distinct().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
            <returns>A sequence that contains distinct elements from the source sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Union().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence whose distinct elements form the first set for the union.</param>
            <param name="second">A sequence whose distinct elements form the second set for the union.</param>
            <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Union().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence whose distinct elements form the first set for the union.</param>
            <param name="second">A sequence whose distinct elements form the second set for the union.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
            <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Intersect().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first"
            >A sequence whose distinct elements that also appear in <b>second</b> will be returned.
            </param>
            <param name="second">
            A sequence whose distinct elements that also appear in the first sequence will be returned.
            </param>
            <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Intersect().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">
            A sequence whose distinct elements that also appear in <b>second</b> will be returned.
            </param>
            <param name="second">
            A sequence whose distinct elements that also appear in the first sequence will be returned.
            </param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
            <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Except().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">
            A sequence whose elements that are not also in <b>second</b> will be returned.
            </param>
            <param name="second">
            A sequence whose elements that also occur in the first sequence will cause those 
            elements to be removed from the returned sequence.
            </param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.IParallelEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Except().
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence whose elements that are not also in <b>second</b> will be returned.</param>
            <param name="second">
            A sequence whose elements that also occur in the first sequence will cause those elements 
            to be removed from the returned sequence.
            </param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.AsEnumerable().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to type as IParallelEnumerable&lt;(Of &lt;(T&gt;)&gt;).</param>
            <returns>The input sequence types as IParallelEnumerable&lt;(Of &lt;(T&gt;)&gt;).</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToArray().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence to create an array from.</param>
            <returns>An array that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.IParallelEnumerable{``0},System.Int32[])">
            <summary>
            Creates a multi-dimensional array from the input data, allowing results of a query
            to be marshaled into a matrix data structure. The array is built by filling the
            array from "left to right, top to bottom."
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An IParallelEnumerable to create an array from.</param>
            <param name="lengths">An array of lengths for the output array. Each int of the 
            array is a dimension, with the value specifying the length of that dimension, in 
            order.</param>
            <returns>A multi-dimensional array that contains the elements of the source 
            sequence, up until the total lengths combined. If length is greater than the 
            number of elements in the source, the remaining elements of the return will be 
            default-filled.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToList().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence to create a List&lt;(Of &lt;(T&gt;)&gt;) from.</param>
            <returns>A List&lt;(Of &lt;(T&gt;)&gt;) that contains elements from the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToDictionary().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains keys and values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToDictionary().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains keys and values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToDictionary().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the value returned by <B>elementSelector</B>.</typeparam>
            <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
            <returns>
            A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains values of type <B>TElement</B> 
            selected from the input sequence
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToDictionary().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the value returned by <B>elementSelector</B>.</typeparam>
            <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector"
            >A transform function to produce a result element value from each element.
            </param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>
            A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains values of type <B>TElement</B> 
            selected from the input sequence
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToLookup().
            </summary>
            <typeparam name="TSource">The type of elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains keys and values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToLookup().
            </summary>
            <typeparam name="TSource">The type of elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains keys and values.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToLookup().
            </summary>
            <typeparam name="TSource">The type of elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the value returned by <B>elementSelector</B>.</typeparam>
            <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
            <returns>
            A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains values of type TElement 
            selected from the input sequence.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.IParallelEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ToLookup().
            </summary>
            <typeparam name="TSource">The type of elements of <B>source</B>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <B>keySelector</B>.</typeparam>
            <typeparam name="TElement">The type of the value returned by <B>elementSelector</B>.</typeparam>
            <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
            <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
            <returns>
            A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains values of type TElement selected 
            from the input sequence.
            </returns>        
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Reverse().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence of values to reverse.</param>
            <returns>A sequence whose elements correspond to those of the input sequence in reverse order.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.IParallelEnumerable)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.OfType(), but differs in the
            parameters. This is a temporary method for this release.
            </summary>
            <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
            <param name="source">The sequence whose elements to filter.</param>
            <returns>A sequence that contains elements from the input sequence of type <B>TResult</B>.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.IParallelEnumerable)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Cast(), but differs in the
            parameters. This is a temporary method for this release.
            </summary>
            <typeparam name="TResult">The type to convert the elements of <B>source</B> to.</typeparam>
            <param name="source">The sequence that contains the elements to be converted.</param>
            <returns>
            A sequence that contains each element of the source sequence converted to the specified type.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.First``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.First().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the first element of.</param>
            <returns>The first element in the specified sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.First``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.First().
            </summary>
            <remarks>There's a temporary difference from LINQ to Objects, this does not throw
            ArgumentNullException when the predicate is null.</remarks>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>The first element in the sequence that passes the test in the specified predicate function.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.FirstOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the first element of.</param>
            <returns>
            default(<B>TSource</B>) if <B>source</B> is empty; otherwise, the first element in <B>source</B>.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.FirstOrDefault().
            </summary>
            <remarks>There's a temporary difference from LINQ to Objects, this does not throw
            ArgumentNullException when the predicate is null.</remarks>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            default(<B>TSource</B>) if <B>source</B> is empty or if no element passes the test 
            specified by <B>predicate</B>; otherwise, the first element in <B>source</B> that 
            passes the test specified by <B>predicate</B>.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Last().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the last element from.</param>
            <returns>The value at the last position in the source sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Last().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            The last element in the sequence that passes the test in the specified predicate function.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.LastOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return an element from.</param>
            <returns>
            default(<B>TSource</B>) if the source sequence is empty; otherwise, the last element in the sequence.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.LastOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            default(<B>TSource</B>) if the sequence is empty or if no elements pass the test in the 
            predicate function; otherwise, the last element that passes the test in the predicate function.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Single().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the single element of.</param>
            <returns>The single element of the input sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.Single().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the single element of.</param>
            <param name="predicate">A function to test an element for a condition.</param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SingleOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the single element of.</param>
            <returns>
            The single element of the input sequence, or default(<B>TSource</B>) if the 
            sequence contains no elements.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.IParallelEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.SingleOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the single element of.</param>
            <param name="predicate">A function to test an element for a condition.</param>
            <returns>
            The single element of the input sequence that satisfies the condition, or 
            default(<B>TSource</B>) if no such element is found.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.IParallelEnumerable{``0})">
            <summary>
            Parallel implementation of System.Linq.Enumerable.DefaultIfEmpty().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return a default value for if it is empty.</param>
            <returns>
            A sequence that contains default(<B>TSource</B>) if <B>source</B> is empty; otherwise, <B>source</B>.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.IParallelEnumerable{``0},``0)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.DefaultIfEmpty().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">The sequence to return the specified value for if it is empty.</param>
            <param name="defaultValue">The value to return if the sequence is empty.</param>
            <returns>
            A sequence that contains <B>defaultValue</B> if <B>source</B> is empty; otherwise, <B>source</B>.
            </returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.IParallelEnumerable{``0},System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ElementAt().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence to return an element from.</param>
            <param name="index">The zero-based index of the element to retrieve.</param>
            <returns>The element at the specified position in the source sequence.</returns>
        </member>
        <member name="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.IParallelEnumerable{``0},System.Int32)">
            <summary>
            Parallel implementation of System.Linq.Enumerable.ElementAtOrDefault().
            </summary>
            <typeparam name="TSource">The type of the elements of <B>source</B>.</typeparam>
            <param name="source">A sequence to return an element from.</param>
            <param name="index">The zero-based index of the element to retrieve.</param>
            <returns>
            default(<B>TSource</B>) if the index is outside the bounds of the source sequence; 
            otherwise, the element at the specified position in the source sequence.
            </returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.TaskGroup">
            <summary>
             A group of tasks.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.ScheduleTask(System.Threading.Tasks.TaskBase,System.Boolean,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
             Schedules a new light-weight (non-work-stealing) task within the specified task group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.ScheduleTask(System.Threading.Tasks.TaskBase)">
            <summary>
             Schedules a new light-weight (non-work-stealing) task within the specified task group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.UnsafeScheduleTask(System.Threading.Tasks.TaskBase)">
            <summary>
             Schedules a new light-weight (non-work-stealing) task within the specified task group.  without capturing and 
             restoring the current execution context.  Note that using this API requires a link demand for ControlEvidence and
             ControlPolicy.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.ScheduleTask(System.Threading.Tasks.TaskBase,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
             Schedules a new light-weight (non-work-stealing) task within the specified task group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.UnsafeScheduleTask(System.Threading.Tasks.TaskBase,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
             Schedules a new light-weight (non-work-stealing) task within the specified task group.  without capturing and 
             restoring the current execution context.  Note that using this API requires a link demand for ControlEvidence and
             ControlPolicy.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.TaskGroup.Release">
            <summary>
            Decrements the reference count of a task group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.#ctor(System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
            Constructs a schedule group with an initial reference count of 1.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.ScheduleTask(System.Threading.Tasks.TaskBase,System.Boolean,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
            Creates a realized (non workstealing) chore in the schedule group. Used to schedule light-weight
            tasks and agents.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.AddRunnableContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Puts a runnable context into the runnables collection in the schedule group. This is usually
            a previously blocked context that was subsequently unblocked, but it could also be an internal
            context executing chores on behalf of an external context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.GetInternalContext">
            <summary>
            Gets an internal context that will look for work in this schedule group
            </summary>
            <returns> An internal context</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.GetInternalContext(System.Threading.Tasks.TaskBase,System.Boolean)">
            <summary>
            Gets an internal context and associates it with a chore.
            </summary>
            <param name="chore"> Chore to associate.</param>
            <param name="choreStolen"> Whether the chore is stolen</param>
            <returns> An internal context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.StealUnrealizedChore">
            <summary>
            Steals an unrealized chore from a workqueue in the schedule group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SafeInternalReference">
            <summary>
            Increments the reference count of the task group only if it is non-zero.
            </summary>
            <returns>
            Returns true, if a reference was taken, false if the reference count was zero.
            </returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.InternalReference">
            <summary>
            Non-virtual function that increments the reference count of a task group.
            </summary>
            <returns> Resulting reference count.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.InternalRelease">
            <summary>
            Non-virtual function that decrements the reference count of a task group. If the reference count
            goes to zero it removes the task group from the ring.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.GetDetachedWorkQueue">
            <summary>
            Attempts to acquire a detached work queue from the schedule group.  If such a work queue is found, it
            is removed from detached mode and returned.  This allows recycling of work queues that are detached
            yet still have unstructured work.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.DetachActiveWorkQueue(System.Threading.ConcurrencyScheduler.WorkQueue)">
            <summary>
            Places a work queue in the detached queue.  This will cause the work queue to remain eligible for stealing 
            while the queue can be detached from a context.  The work queue will be recycled and handed back to a 
            context executing within the schedule group that needs a queue.  If the queue is not recycled, it will be
            abandoned and freed when it becomes empty (a steal on it while in detached mode fails).
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForRealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds an realized chore for the context to execute.
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.StealUnrealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds a stolen chore for the context to execute.
             Searches for a stolen chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForRealizedContext">
            <summary>
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.StealUnrealizedContext">
            <summary> 
             Searches for a unrealized chore to steal in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForRunnableInBlock(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Searches for a runnable context to execute in place of a context that is about to block.
            </summary>
            <param name="virtualProcessor"> The virtual processor the current context is executing on.</param>
            <returns> A runnable context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForRunnableInYield(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Searches for a runnable context to execute in place of a context that is about to yield.
            </summary>
            <param name="virtualProcessor">The virtual processor the current context is executing on.</param>
            <returns> A runnable context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForRunnableInDispatch(System.Threading.ConcurrencyScheduler.VirtualProcessor,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
            Searches for a runnable context to execute in the dispatch loop when the current context is done with executing a chore.
            </summary>
            <param name="virtualProcessor">The virtual processor the current context is executing on.</param>
            <returns> A runnable context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForContextInYield(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Searches for a context to execute in the place of a context that is about to yield. This could be an unblocked context
            or a new context associated with a realized chore or stolen unrealized chore.
            </summary>
            <param name="virtualProcessor">The virtual processor the current context is executing on.</param>
            <returns> An internal context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.SearchForContextInBlock(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Searches for a context to execute in the place of a context that is about to block. This could be an unblocked context
            or a new context associated with a realized chore or stolen unrealized chore.
            </summary>
            <param name="virtualProcessor">The virtual processor the current context is executing on.</param>
            <returns> An internal context.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.Reference">
            <summary>
            Increments the reference count of a task group.  Used for composition.
            </summary>
            <returns>Returns the resulting reference count.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ScheduleGroup.Release">
            <summary>
            Decrements the reference count of a task group.  Used for composition.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ScheduleGroup.Id">
            <summary>
            Returns a unique identifier to the schedule group.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ScheduleGroup.HasRealizedChores">
            <summary>
            Returns true if the group has any realized chores.
            This is used during scheduler finalization when only one thread is active in the scheduler.
            At any other time this information is stale since new work could get added to the scheduler.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ScheduleGroup.HasUnrealizedChores">
            <summary>
            Returns true if any of the workqueues in the schedule group has unrealized chores.
            This is used during scheduler finalization when only one thread is active in the scheduler.
            At any other time this information is stale since new work could get added to the scheduler.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ScheduleGroup.IsFairScheduleGroup">
            <summary>
            Tells whether the schedule group schedules work in a fair manner.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.AddRunnableContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Puts a runnable context into the runnables collection in the schedule group. This is usually
            a previously blocked context that was subsequently unblocked, but it could also be an internal
            context executing chores on behalf of an external context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.GetRunnableContext">
            <summary>
            Finds a runnable context in this schedule group
            </summary>
            <returns>A runnable context</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.SearchForRealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds an realized chore for the context to execute.
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.StealUnrealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds a stolen chore for the context to execute.
             Searches for a stolen chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.SearchForRealizedContext">
            <summary>
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.StealUnrealizedContext">
            <summary> 
             Searches for a unrealized chore to steal in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.SearchForRunnableInBlock(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Helper for SearchForContextInBlock - uses the same algorithm as the one used for searching for a runnable
            in the dispatch loop.
            </summary>
            <param name="virtualProcessor"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.SearchForRunnableInYield(System.Threading.ConcurrencyScheduler.VirtualProcessor)">
            <summary>
            Helper for SearchForContextInYield
            Algorithm is as follows:
             1. Look for work in a runnable context of a different scheduling group in the same scheduling node
             2. Look for work by stealing local runnables within the same scheduling node
             3. Look for work in the list of runnable contexts within the same schedule group
             4. Look for work in the VirtualProcessor's local runnable queue
            </summary>
            <param name="virtualProcessor"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CacheLocalScheduleGroup.SearchForRunnableInDispatch(System.Threading.ConcurrencyScheduler.VirtualProcessor,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
            Called in Dispatch
            Algorithm is as follows:
             1. Look for work in the VirtualProcessor's local runnable queue
             2. Look for work in the list of runnable contexts within the same schedule group
             3. Look for work by stealing local runnables within the same scheduling node
             4. Look for work in a runnable context of a different scheduling group in the same scheduling node
            </summary>
            <param name="virtualProcessor"></param>
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ChorePool">
            <summary>
            Chore pool represents an abstract set of work and provides shared waiting semantics for stolen
            work.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ChorePool.#ctor">
            <summary>
            Constructs a new chore pool.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ChorePool.WaitOnStolenChores(System.Int64)">
            <summary>
            Waits on a specified number of stolen chores.
            </summary>
            <param name="stolenChoreCount">The number of stolen chores to wait upon</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ChorePool.CountUp">
            <summary>
            Indicates that a stolen chore has completed.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ChorePool.m_unpoppedChores">
            <summary>
            The number of unpopped chores associated with the chore pool (set by the derived
            class during chore association.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ChorePool.Initialize">
            <summary>
            Internal initialization of the chore pool
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.#ctor(System.Threading.ConcurrencyScheduler.Scheduler)">
            <summary>
             Constructor
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.Block">
            <summary>
            Causes the current context to block, yielding execution to another context.  If the current
            thread does not have a ConcRT context associated with it, it is inducted into one.
            </summary>       
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.Unblock">
            <summary>
            Unblocks the internal context putting it on the runnables collection in its schedule group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.Yield">
            <summary>
            Yields execution so that another context may execute.  The current context is placed on the
            scheduler's list of runnable contexts.  If the current thread does not have a context, it is inducted
            into a ConcRT context.  If no other function is available to yield to, the function simply returns.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.Oversubscribe(System.Boolean)">
             <summary>
             Depending on the argument, hints that the scheduler should add an extra virtual processor for the
             duration of a block of code or remove a previously added one.
            
                 Oversubscribe(TRUE);
                 /* some slow kernel or I/O code, etc.*/
                 Oversubscribe(FALSE);
            
             An extra virtual processor could be allocated on the current hardware thread between the two calls
             to OverSubscribe. The call is only a hint to the scheduler, and the scheduler may decide not to add
             the virtual processor, either if there is no work or additional idle virtual processors are available.
             Calls to OverSubscribe(TRUE) must be matched with calls to OverSubscribe(FALSE) -> calls can be nested,
            but only a maximum of one additional virtual processor is created. The additional vproc, if any, will
             be retired after the outermost call to OverSubscribe(FALSE), as soon as the currently executing root
             chore on the vproc is completed. No error state.
             </summary>
             <param name="oversubscribe">A boolean value specifying whether oversubscription is to be turned
             on or off</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PushStructuredChore(System.Threading.Tasks.TaskBase,System.Boolean)">
            <summary>
            Pushes the chore specified by task onto the structured work stealing queue associated with the
            specified context.
            </summary>
            <param name="task">The chore to push onto the structured work stealing queue</param>
            <param name="suppressContextFlow">Indicates whether or not to suppress the flow of .NET execution
            context flow from the calling thread to the thread which actually executes the chore.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PushStructuredChore(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes the chore specified by task onto the structured work stealing queue associated with the
            specified context.
            </summary>
            <param name="task">The chore to push onto the structured work stealing queue</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.UnsafePushStructuredChore(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes the chore specified by task onto the structured work stealing queue associated with the
            specified context without capturing and restoring execution context.  Note that using this method requires a check
            for ControlEvidence and ControlPolicy.
            </summary>
            <param name="task">The chore to push onto the structured work stealing queue</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PopStructuredChore">
            <summary>
            Attempts to pop the topmost chore on the structured work stealing queue and return it.
            </summary>
            <returns>The topmost chore on the structured work stealing queue or null if no such chore can
            be found.  Failure to pop (e.g.: a return value of null) typically indicates that the chore
            was stolen by another processor.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PushUnstructuredChore(System.Threading.Tasks.TaskBase,System.Boolean)">
            <summary>
            Pushes the chore specified by task onto the unstructured work stealing queue associated with the
            specified context.
            </summary>
            <param name="task">The chore to push onto the unstructured work stealing queue</param>
            <param name="suppressContextFlow">Indicates whether or not to suppress the flow of .NET execution
            context flow from the calling thread to the thread which actually executes the chore.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PushUnstructuredChore(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes the chore specified by task onto the unstructured work stealing queue associated with the
            specified context.
            </summary>
            <param name="task">The chore to push onto the unstructured work stealing queue</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.UnsafePushUnstructuredChore(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes the chore specified by task onto the unstructured work stealing queue associated with the
            specified context without capturing and restoring the execution context.  Note that using this method requires
            a check for ControlEvidence and ControlPolicy.
            </summary>
            <param name="task">The chore to push onto the unstructured work stealing queue</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.TryPopUnstructuredChore(System.Threading.Tasks.TaskBase)">
            <summary>
            Attempts to remove the specified chore from the unstructured work stealing queue associated with
            the specified context.  Note that the attempt may be made for a chore at any position in the work
            stealing queue.  If false is returned, the given task could not be removed from the work stealing
            queue and it can be assumed that either the task was stolen or that the routine is running from a
            differing thread.
            </summary>
            <param name="task">The chore to attempt to pop from the unstructured work stealing queue.</param>
            <returns>An indication of whether or not the chore could be removed from the unstructured work
            stealing queue.  If true is returned, the chore has been popped.  If false is returned, the caller
            may assume that either the chore was stolen (if on the same context it was pushed from) or that the
            routine is being called from a different context from the one where the specified task was pushed.
            </returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.Cleanup">
            <summary>
            Cleans up the Context
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.EnterCriticalRegion">
            <summary>
            Enters a critical region of the scheduler.  Calling this guarantees that the virtual processor on which this context lives
            is guaranteed to be stable throughout the critical region.  For some context types, this is virtually a NOP.  For others 
            (UMS), this makes it appear that blocking on the context actually blocks the UMS thread instead of triggering return to 
            primary.  Callers should make no attempt to do a cooperative context switch during a critical region!
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.ExitCriticalRegion">
            <summary>
            Exits a critical region of the scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.ReleaseWorkQueue">
            <summary>
            Clean up the work queue for this Context
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PopContextFromTls">
            <summary>
            When schedulers are nested on the same stack context, the nested scheduler creates a new external context that overrides 
            the previous context. PopTls will restore the previous context by setting the TLS value appropriately.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.PushContextToTls(System.Threading.ConcurrencyScheduler.Context)">
            <summary>
            When schedulers are nested on the same stack context, the nested scheduler creates a new external context that overrides 
            the previous context. PushTls will store the previous context and set the new context into TLS.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Context.ClearContextTls">
            <summary>
            Context TLS is cleared during nesting on internal contexts before the external context TLS is correctly setup. If not,
            code that executes between the clear and setting the new TLS could get confused.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.CurrentContext">
            <summary>
            A pointer to the ConcRT context associated with the current thread it if exists. If one
            does not exist, a new context is created.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.FastCurrentContext">
            <summary>
             The current ConcRT context.  This does not perform lazy initialization.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.Id">
            <summary>
            A per scheduler unique identifier for the context.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.VirtualProcessorId">
            <summary>
            An identifier for the virtual processor the context is currently executing on.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.CurrentTask">
            <summary>
            The current task executing on the specified context. The value returned is only
            meaningful if called on the currently running context (e.g.: Context.CurrentContext.CurrentTask).
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.Scheduler">
            <summary>
            The scheduler that the specified scheduler instance is associated with.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:System.Threading.ConcurrencyScheduler.Context.GetTaskGroupId" -->
        <!-- Badly formed XML comment ignored for member "P:System.Threading.ConcurrencyScheduler.Context.TaskGroupRefCount" -->
        <!-- Badly formed XML comment ignored for member "P:System.Threading.ConcurrencyScheduler.Context.UnderlyingId" -->
        <member name="P:System.Threading.ConcurrencyScheduler.Context.IsInCriticalRegion">
            <summary>
            Checks if a context is in a critical region.  This is only safe from either the current context or from a UMS primary which
            has woken due to a given context blocking.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Context.WorkQueue">
            <summary>
            Wrapper for m_workQueue that perform delay construction as well as insertion into task group.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:System.Threading.ConcurrencyScheduler.Context.IsExternal" -->
        <member name="P:System.Threading.ConcurrencyScheduler.Context.PairedContext">
            <summary>
            Gets the other context in the internal-external context pair
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.IContextProvider">
            <summary>
             A context provider captures context affine data when an asynchronous piece of work is scheduled
             and restores it when the task executes some arbitrary context.  This is a generalization of
             execution context flow.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.IContextProvider.CaptureContextData(System.Threading.Tasks.TaskBase,System.Threading.Tasks.TaskTypes)">
            <summary>
             Called in order to capture any context affine data when a task is scheduled.  The task being
             scheduled as well as its schedule type is passed to the provider.
            </summary>
            <params name="task">The task being scheduled</params>
            <params name="taskType">The schedule type of the specified task</params>
            <returns>
             An opaque blob of data which the context provider can later use to restore context affine
             data on some arbitrary context.
            </returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.IContextProvider.RestoreContextData(System.Threading.Tasks.TaskBase,System.Threading.Tasks.TaskTypes,System.Boolean,System.Object)">
            <summary>
             Called in order to restore a specified set of context affine data to the current execution
             context.  
            </summary>
            <params name="task">The task which is going to execute</params>
            <params name="taskType">The schedule type of the task in question</params>
            <params name="inline">An indication of whether the task was inlined or not (e.g.: executed
                                  on the same context where it was scheduled)</params>
            <params name="contextBlob">The opaque data to restore</params>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.IContextProvider.ClearContextData(System.Threading.Tasks.TaskBase,System.Threading.Tasks.TaskTypes,System.Boolean,System.Object)">
            <summary>
             Called in order to clear out a specified set of context affine data from the current
             execution context.
            </summary>
            <params name="task">The task which just finished executing</params>
            <params name="taskType">The schedule type of the task in question</params>
            <params name="inline">An indication of whether the task was inlined or not (e.g.: executed
                                  on the same context where it was scheduled)</params>
            <params name="contextBlob">The opaque data to clear</params>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ContextData">
            <summary>
             An association between a provider and its data
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextData.#ctor(System.Threading.ConcurrencyScheduler.IContextProvider,System.Object)">
            <summary>
             Constructs a new provider/data set
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ContextData.m_provider">
            <summary>
             The provider
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ContextData.m_contextBlob">
            <summary>
             Context affine data associated with the provider
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ContextData.Provider">
            <summary>
             The provider
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ContextData.ContextBlob">
            <summary>
             Context affine data associated with the provider
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.EventWaitNode">
            <summary>
            An event wait node represents an abstract wait block which is chained to each event such that when the
            event is signaled, the wait block is notified and performs the appropriate unblocking (or additional
            waiting) required.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SentinelNode">
            <summary>
            An internal "dummy" class which has a single purpose -- act as a sentinel in the wait chain.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WaitBlock">
            <summary>
            Represents a wait block.  It is indirectly chained to an event via an EventWaitNode
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitBlock.#ctor">
            <summary>
            Constructs a new wait block.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitBlock.Satisfy(System.Threading.ConcurrencyScheduler.Context@,System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
            Called when the wait is satisfied (the event is signaled).  Note that the derived class may or may
            not unblock depending on the exact wait semantics.
            </summary>
            <param name="contextOut">Returns the context which needs unblocked</param>
            <returns>An indication of whether the event needs to track this node after a signal due to the potential
            for a reset to impact the overall wait.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitBlock.Reset">
            <summary>
            Called when the event is reset.  A wait-all may need to adjust counters to prevent the wait from being
            satisfied.
            </summary>
            <returns>An indication of whether the wait node is still valid</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitBlock.Sweep">
            <summary>
            Called in order to check whether a node is still alive or dead during a list sweep
            </summary>
            <returns>Whether the node is still alive or dead</returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SingleWaitBlock">
            <summary>
            Represents a wait block for a single event wait.  It is directly chained to an event.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SingleWaitBlock.#ctor">
            <summary>
            Constructs a wait node for a wait-for-single type of wait
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SingleWaitBlock.Satisfy(System.Threading.ConcurrencyScheduler.Context@,System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
            Called in order to satisfy a wait-for-single type of wait.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the satisfy</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SingleWaitBlock.Reset">
            <summary>
            Called in order to notify a wait-for-single type of wait that the event reset.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the reset</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SingleWaitBlock.Sweep">
            <summary>
            Called during a sweep to check whether this node still needs to be alive.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.MultiWaitBlock">
            <summary>
            Represents a wait block for a multi-event wait.  It is indirectly chained to an event via
            a Wait*Node
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.MultiWaitBlock.#ctor(System.Int32,System.Boolean)">
            <summary>
            MultiWaitBlock constructor.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.MultiWaitBlock.SingleSatisfy(System.Threading.ConcurrencyScheduler.Context@,System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
            Called when a multiple-wait satisfies its "multiple" condition.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.MultiWaitBlock.DispatchEventTimer(System.Object)">
            <summary>
            Called when a timer on the wait block fires.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WaitAnyBlock">
            <summary>
            Represents a wait entry chained to an event for an "any" type of wait.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAnyBlock.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a new wait node for a wait-for-all type of wait
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAnyBlock.Satisfy(System.Threading.ConcurrencyScheduler.Context@,System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
            Called in order to satisfy a wait-for-any type of wait.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the satisfy</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAnyBlock.Reset">
            <summary>
            Called in order to notify a wait-for-all type of wait than an event reset.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the reset</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAnyBlock.Sweep">
            <summary>
            Called during a sweep to check whether this node still needs to be alive.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WaitAllBlock">
            <summary>
            Represents a wait entry chained to an event for an "all" type of wait.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAllBlock.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a new wait node for a wait-for-all type of wait
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAllBlock.Satisfy(System.Threading.ConcurrencyScheduler.Context@,System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
            Called in order to satisfy a wait-for-all type of wait.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the satisfy</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAllBlock.Reset">
            <summary>
            Called in order to notify a wait-for-all type of wait than an event reset.
            </summary>
            <returns>An indication of whether the wait node needs to be tracked past the reset</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WaitAllBlock.Sweep">
            <summary>
            Called during a sweep to check whether this node still needs to be alive.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.CooperativeEvent">
            <summary>
            A cooperative event which understands the specific semantics of the scheduler and can block and reschedule
            as appropriate with no kernel transitions.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.#ctor">
            <summary>
            Constructs a new event.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Wait">
            <summary>
            Waits on the cooperative event.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Wait(System.Int32)">
            <summary>
            Waits on the cooperative event with a specified timeout.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds after which to time out the wait</param>
            <returns>true if the wait was satisfied, false is the wait timed out</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Wait(System.TimeSpan)">
            <summary>
            Waits on the cooperative event with a specified timeout.
            </summary>
            <param name="timeout">A timespan specifying when to time out the wait</param>
            <returns>true if the wait was satisfied, false is the wait timed out</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Set">
            <summary>
            Signals the event.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Reset">
            <summary>
            Resets the event to a non-signaled state.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAll(System.Threading.ConcurrencyScheduler.CooperativeEvent[])">
            <summary>
            Waits for all events to become signaled.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <returns>An indication if every cooperative event was signaled</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAll(System.Threading.ConcurrencyScheduler.CooperativeEvent[],System.Int32)">
            <summary>
            Waits for all events to become signaled with a timeout.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <param name="millisecondsTimeout">The number of milliseconds after which to time out the wait</param>
            <returns>An indication if every cooperative event was signaled (false indicates timeout)</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAll(System.Threading.ConcurrencyScheduler.CooperativeEvent[],System.TimeSpan)">
            <summary>
            Waits for all events to become signaled with a timeout.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <param name="timeout">A timespan specifying when to time out the wait</param>
            <returns>An indication if every cooperative event was signaled (false indicates timeout)</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAny(System.Threading.ConcurrencyScheduler.CooperativeEvent[])">
            <summary>
            Waits for any event to become signaled.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <returns>The index of the event which finally satisfied the wait</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAny(System.Threading.ConcurrencyScheduler.CooperativeEvent[],System.Int32)">
            <summary>
            Waits for any event to become signaled with a timeout.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <param name="millisecondsTimeout">The number of milliseconds after which to time out the wait</param>
            <returns>The index of the event which finally satisfied the wait or CooperativeWaitTimeout if the timeout did</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitAny(System.Threading.ConcurrencyScheduler.CooperativeEvent[],System.TimeSpan)">
            <summary>
            Waits for any event to become signaled with a timeout.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <param name="timeout">A timespan specifying when to time out the wait</param>
            <returns>The index of the event which finally satisfied the wait or CooperativeWaitTimeout if the timeout did</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Wait(System.Int64)">
            <summary>
            Waits for the event to become signaled.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.WaitForMultipleEvents(System.Threading.ConcurrencyScheduler.CooperativeEvent[],System.Boolean,System.Int64)">
            <summary>
            Waits for multiple events to become signaled.
            </summary>
            <param name="events">An array of events to wait upon</param>
            <param name="waitAll">An indication of whether to wait for all events or just a single one</param>
            <param name="timeout">The number of milliseconds after which to time out the wait</param>
            <returns>The index of the event which finally satisfied the wait or CooperativeWaitTimeout if the timeout did</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.Sweep(System.Threading.ConcurrencyScheduler.EventWaitNode)">
            <summary>
             Called in order to sweep out unused entries from a given node list.  This clears dead wait-for-all nodes
             on a reset-list or dead wait-for-any nodes on the wait-list.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.CooperativeEvent.SortByLock(System.Threading.ConcurrencyScheduler.CooperativeEvent[])">
            <summary>
             Sorts a list of events by lock to allow for selectively granular locking in wait-for-multiple.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerResourceAllocationException">
            <summary>Exception thrown due to failure to acquire a critical resource in the concurrency runtime</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerResourceAllocationException.#ctor(System.Int32)">
            <summary>Construct a SchedulerResourceAllocationError exception with an error code</summary>
            <param name="errorCode">Error code of error that caused this exception</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerResourceAllocationException.#ctor(System.String,System.Int32)">
            <summary>Construct a SchedulerResourceAllocationError exception with a message and an error code</summary>
            <param name="message">Descriptive message of error</param>
            <param name="errorCode">Error code of error that caused this exception</param>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerResourceAllocationException.ErrorCode">
            <summary>Get the error code that caused this exception</summary>
            <returns>Error code of error that caused the exception</returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.InsufficientHardwareThreadsException">
            <summary>Exception thrown when we cannot get sufficient hardware threads</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InsufficientHardwareThreadsException.#ctor">
            <summary>Construct an InsufficientHardwareThreads exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InsufficientHardwareThreadsException.#ctor(System.String)">
            <summary>Construct an InsufficientHardwareThreads exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerNotAttachedException">
            <summary>
            Exception thrown whenever a required scheduler hasn't been attached to the current context
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerNotAttachedException.#ctor">
            <summary>Construct a SchedulerNotAttached exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerNotAttachedException.#ctor(System.String)">
            <summary>Construct a SchedulerNotAttached exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ImproperSchedulerAttachException">
            <summary>
            Exception thrown whenever Scheduler::Attach is called from an internal context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ImproperSchedulerAttachException.#ctor">
            <summary>Construct a ImproperSchedulerAttach exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ImproperSchedulerAttachException.#ctor(System.String)">
            <summary>Construct a ImproperSchedulerAttach exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ImproperSchedulerDetachException">
            <summary>
            Exception thrown whenever detach is called from an external context
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ImproperSchedulerDetachException.#ctor">
            <summary>Construct a ImproperSchedulerDetach exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ImproperSchedulerDetachException.#ctor(System.String)">
            <summary>Construct a ImproperSchedulerDetach exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.DefaultSchedulerExistsException">
            <summary>
            Exception thrown whenever a scheduler is set to default in the presence of an 
            existing default scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.DefaultSchedulerExistsException.#ctor">
            <summary>Construct a DefaultSchedulerExists exception with a message</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.DefaultSchedulerExistsException.#ctor(System.String)">
            <summary>Construct a DefaultSchedulerExists exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ContextUnblockUnbalancedException">
            <summary>
            Exception thrown whenever context block/unblock are unbalanced
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextUnblockUnbalancedException.#ctor">
            <summary>Construct a ContextUnblockUnbalanced exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextUnblockUnbalancedException.#ctor(System.String)">
            <summary>Construct a ContextUnblockUnbalanced exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.StructuredNotEmptyException">
            <summary>
            Exception thrown whenever a structured workstealing queue is not empty when the workqueue is detached.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredNotEmptyException.#ctor">
            <summary>Construct a StructuredNotEmpty exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredNotEmptyException.#ctor(System.String)">
            <summary>Construct a StructuredNotEmpty exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicy">
            <summary>
             Exception thrown whenever a policy fails SchedulerPolicy.IsValid.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicy.#ctor">
            <summary>Construct a InvalidSchedulerPolicy exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicy.#ctor(System.String)">
            <summary>Construct a InvalidSchedulerPolicy exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyKey">
            <summary>
             Exception thrown whenever an invalid key is specified.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyKey.#ctor">
            <summary>Construct a InvalidSchedulerPolicyKey exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyKey.#ctor(System.String)">
            <summary>Construct a InvalidSchedulerPolicyKey exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyValue">
            <summary>
             Exception thrown whenever an invalid value is specified.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyValue.#ctor">
            <summary>Construct a InvalidSchedulerPolicyValue exception</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InvalidSchedulerPolicyValue.#ctor(System.String)">
            <summary>Construct a InvalidSchedulerPolicyValue exception with a message</summary>
            <param name="message">Descriptive message of error</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ExternalContext.#ctor(System.Threading.ConcurrencyScheduler.Scheduler,System.Boolean)">
            <summary>
            Constructs the base class object for an external context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ExternalContext.Suspend">
            <summary>
            Suspends the external context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ExternalContext.Resume">
            <summary>
            Resumes the external context.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.ConcurrencyScheduler.ExternalContext.ScheduleTaskPoolWait(System.Threading.ConcurrencyScheduler.ChorePool,System.Boolean)" -->
        <member name="M:System.Threading.ConcurrencyScheduler.FairScheduleGroup.AddRunnableContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Puts a runnable context into the runnables collection in the schedule group. This is usually
            a previously blocked context that was subsequently unblocked, but it could also be an internal
            context executing chores on behalf of an external context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.FairScheduleGroup.SearchForRealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds an realized chore for the context to execute.
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.FairScheduleGroup.StealUnrealizedChore(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.SchedulingRing)">
            <summary>
             Finds a stolen chore for the context to execute.
             Searches for a stolen chore in the current schedule group, followed by all other schedule groups in
             the node. If a chore is found in a schedule group different from the current one, then m_pGroup is
             modified to reflect that.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.FairScheduleGroup.SearchForRealizedContext">
            <summary>
             Searches for a realized chore in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.FairScheduleGroup.StealUnrealizedContext">
            <summary> 
             Searches for a unrealized chore to steal in the current schedule group, followed by all other schedule groups in
             the node.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.InternalContext">
            <summary>
            Implements the base class for ConcRT internal contexts.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.#ctor(System.Threading.ConcurrencyScheduler.Scheduler)">
            <summary>
            Constructs the base class object for an internal context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.Block">
            <summary>
            Causes the internal context to block yielding the virtual processor to a different internal context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.Unblock">
            <summary>
            Unblocks the internal context putting it on a runnables collection in its schedule group.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.Yield">
            <summary>
            Yields the virtual processor to a different runnable internal context if one is found.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.SpinUntilBlocked">
            <summary>
            Spins until the 'this' context is in a firmly blocked state
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.AddToRunnables">
            <summary>
            Adds the context to a runnables collection, either on the virtual processor, or the schedule group
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.SwitchTo(System.Threading.ConcurrencyScheduler.InternalContext,System.Threading.ConcurrencyScheduler.InternalContext.ReasonForSwitch)">
            <summary>
            Switches from one internal context to another.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.SwitchOut(System.Threading.ConcurrencyScheduler.InternalContext.ReasonForSwitch)">
            <summary>
            Switches out the internal context. Useful, when the virtual processor is to be retired.
            Is also used when un-nesting a scheduler and the context is returning to its original scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.Dispatch">
            <summary>
            Main dispatch loop which executes work until canceled.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.Cancel">
            <summary>
            Cancels the context, causing it to exit the dispatch loop.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.LeaveScheduler">
            <summary>
            Called when a context is nesting a scheduler. If nesting takes place on what is an internal context in
            the 'parent' scheduler, the context must return the virtual processor to the parent scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.RejoinScheduler">
            <summary>
            Called when a context is un-nesting a scheduler. If the parent context is an internal context, it needs
            to rejoin the parent scheduler by looking for a virtual processor it can execute on.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.InternalContext.ExecuteContext">
            <summary>
            Called by an idle virtual processor to execute this internal thread context.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.InternalContext.VirtualProcessorId">
            <summary>
            Returns an identifier to the virtual processor the context is currently executing on, if any.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.InternalContext.CurrentTask">
            <summary>
            The current task executing on the specified context. The value returned is only
            meaningful if called on the currently running context (e.g.: Context.CurrentContext.CurrentTask).
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.Lock">
            <summary>
            Lock base class, primarily used for passing in pointers or references to the
            locks that are really taken.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.NonReentrantLock">
            <summary>
            A Non-reentrant Lock is intended for use in situations where it is known that the 
            lock will not be taken recursively, and can thus be more efficiently implemented.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NonReentrantLock.Acquire">
            <summary>
            Acquire the lock using an Interlocked.Exchange on Lock.  After InternalSpinCount
            number of retries, it will begin calling Thread.Sleep(0).
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NonReentrantLock.TryAcquire">
            <summary>
            Try to acquire the lock, does not spin if it is unable to acquire.
            </summary>  
            <returns>A bool indicating whether the lock was acquired or not</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NonReentrantLock.Release">
            <summary>
            Release the lock, which can be safely done without a memory barrier
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ReaderWriterLock">
            <summary>
            A Reader-Writer Lock is intended for use in situations with many readers and rare 
            writers.  
            </summary>
            <remarks>
            A writer request immediately blocks future readers and then waits until all current
            readers drain.  A reader request does not block future writers and must wait until 
            all writers are done, even those that cut in front of it.  In any race between a
            reader and a writer, the writer always wins.
            </remarks>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.AcquireRead">
            <summary>
            Acquires the RWLock for reading.  Waits for the number of writers to drain.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.ReleaseRead">
            <summary>
            Release read lock -- the last reader will decrement InternalState to State::Free
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.AcquireWrite">
            <summary>
            Acquire write lock -- spin until there are no existing readers, no new readers will 
            be added
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.ReleaseWrite">
            <summary>
            Release writer lock -- there can only be one active, but a bunch might be pending
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.TryAcquireWrite">
            <summary> Mapped to by TryAcquire().  Assumes user will do their own spinning. </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.UpgradeToWrite">
            <summary>
            Upgrade from reader to writer keeping the read state active so another writer cannot slip 
            in -- this is not fair to other pending writers, hence we're assuming an UpgradeToWrite 
            takes priority over all existing writers and all subsequent readers.  This makes sense, 
            since we already had a reader lock which prevented any other writers from acquiring a lock.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.DowngradeToRead">
            <summary>
            Downgrade from writer to reader -- trivial state alteration that blocks any other writer 
            locks from cutting in front of aqcuiring the reader lock.  However, if there are pending 
            writers then they will block additional readers.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.Acquire">
            <summary> Mapped to AcquireWrite() </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.TryAcquire">
            <summary> Mapped to TryAcquireWrite() </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ReaderWriterLock.Release">
            <summary> Mapped to Release() </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ReaderWriterLock.HasReadLock">
            <summary> 
            Checks to see if the lock is held in read state. 
            </summary>
            <returns> Returns true if it is in read state, false otherwise </returns>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ReaderWriterLock.HasWriteLock">
            <summary> 
            Checks to see if the lock is held in write state. 
            </summary>
            <returns> Returns true if it is in write state, false otherwise </returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ResourceManager.#ctor">
            <summary>
            Resource Manager Constructor
            </summary>
            <remarks>
            Determines the number of processors and the OS version
            </remarks>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ResourceManager.RequestHardwareThreads(System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement,System.UInt16[],System.Byte[],System.UInt16@)">
            <summary>
            When a scheduler is created for the first time, an ISchedulerResourceManagement* 
            is passed in.  When RM has assigned cores it returns those in the preallocated arrays 
            passed in and the scheduler is set with 
                scheduler.SetSchedulerId(...).  
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerShutdownEventArgs">
            <summary>
             Event arguments for scheduler shutdown event.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerShutdownEventArgs.#ctor(System.Threading.ConcurrencyScheduler.Scheduler)">
            <summary>
             Constructs a new shutdown event argument structure
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerShutdownEventArgs.ShutdownScheduler">
            <summary>
             Exposes the scheduler which is shutting down
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextExitEventHandler.Start">
            <summary>
            Starts a new background thread to handle context exit events.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextExitEventHandler.Cancel">
            <summary>
            Cancels the thread backing the event handler and causes it to exit.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ContextExitEventHandler.HandlerStartRoutine(System.IntPtr)">
            <summary>
            Thread start routine for the handler - a delegate to this is passed into a P/Invoke to CreateThread
            </summary>
            <param name="dummy"> Unused parameter </param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.Scheduler">
            <summary>
             Abstraction for a scheduler.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Scheduler.MAXIMUM_WAIT_OBJECTS">
            <summary>
            Constants for the background thread.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateScheduler(System.Threading.ConcurrencyScheduler.SchedulerPolicy)">
            <summary>
             Creates a scheduler that only managed internal contexts.  Implicitly calls Reference.
             If Attach is called, the scheduler is no longer anonymous because it is also managing the external
             context where Attach was called.  To destroy an anonymous scheduler, Release needs to be called.
            </summary>
            <param name="policy">The scheduling policy to utilize in creating the scheduler</param>
            <returns>A new scheduler instance</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateSchedulerAsCurrent(System.Threading.ConcurrencyScheduler.SchedulerPolicy)">
            <summary>
             Creates a scheduler which is attached to the current context.  Implicitly calls Attach.  To destroy
             such a scheduler, Detach needs to be called.
            </summary>
            <param name="policy">The scheduling policy to utilize in creating the scheduler</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Detach">
            <summary>
             Detaches the current scheduler from the calling thread and restores the previously attached scheduler as the
             current scheduler.  Implicitly calls Release.  After this function is called, the calling hread is then managed
             by the scheduler that was previously activated via Create() or Attach().
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.RegisterContextProvider(System.Threading.ConcurrencyScheduler.IContextProvider,System.Threading.Tasks.TaskTypes,System.Boolean)">
            <summary>
             Registers a context provider statically with the scheduling system.  This context provider will be called to capture,
             restore, and clear context before and after each work item executed on the scheduler.  Note that this API statically
             registers the provider.  Registering a provider will affect every scheduler instance within the application domain.
            </summary>
            <params name="provider">The provider to register</params>
            <params name="taskTypes">The task types the provider is implicitly called for</params>
            <params name="invokeInline">An indication of whether or not to call the provider for tasks executed inline</params>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Reference">
            <summary>
             Increments a reference count to this scheduler to manage lifetimes over composition.  This reference
             count is known as the scheduler reference count.
            </summary>
            <returns>The resulting reference count is returned</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Release">
            <summary>
             Decrements this scheduler's reference count to manage lifetimes over composition.  A scheduler
             starts the shutdown protocol when the scheduler reference count goes to zero.
            </summary>
            <returns>The resulting reference count is returned</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Attach">
            <summary>
             Attaches this scheduler to the calling thread.  Implicitly calls Reference.  After this function is called,
             the calling thread is then managed by the scheduler and the scheduler becomes the current scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateTaskGroup">
            <summary>
              Creates a new task group within this scheduler.
            </summary>
            <returns>A newly created task group</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ScheduleTask(System.Threading.Tasks.TaskBase,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
             Creates and schedules a light-weight task within the current scheduler in an anonymous task group.
            </summary>
            <param name="task">The task to schedule</param>
            <param name="contextData">A set of context data manually provided to flow to the task</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.UnsafeScheduleTask(System.Threading.Tasks.TaskBase,System.Threading.ConcurrencyScheduler.ContextData[])">
            <summary>
             Creates and schedules a light-weight task within the current scheduler in an anonymous task group without capturing and 
             restoring the current execution context.  Note that using this API requires a link demand for ControlEvidence and
             ControlPolicy.
            </summary>
            <param name="task">The task to schedule</param>
            <param name="contextData">A set of context data manually provided to flow to the task</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ScheduleTask(System.Threading.Tasks.TaskBase)">
            <summary>
             Creates and schedules a light-weight task within the current scheduler in an anonymous task group.
            </summary>
            <param name="task">The task to schedule</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.UnsafeScheduleTask(System.Threading.Tasks.TaskBase)">
            <summary>
             Creates and schedules a light-weight task within the current scheduler in an anonymous task group without capturing and
             restoring the current execution context.  Note that using this API requires a link demand for ControlEvidence and
             ControlPolicy.
            </summary>
            <param name="task">The task to schedule</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateVirtualProcessor(System.Threading.ConcurrencyScheduler.SchedulingNode,System.Threading.ConcurrencyScheduler.VirtualProcessorGroup)">
            <summary>
             Creates the appropriate type of virtual processor.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateInternalContext">
            <summary>
             Returns a newly constructed internal context appropriate to the given type of scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CreateExternalContext(System.Boolean)">
            <summary>
             Creates an external context and attaches it to the calling thread.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNextSchedulingNode">
            <summary>
             Gets the next scheduling node.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNextSchedulingNode(System.Threading.ConcurrencyScheduler.SchedulingNode,System.Threading.ConcurrencyScheduler.SchedulingNode)">
            <summary>
            Find the next scheduling node in the heirarchy. This is currently naive round-robin.
            </summary>
            <param name="owningNode"></param>
            <param name="currentNode"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.SetNextSchedulingNode(System.Threading.ConcurrencyScheduler.SchedulingNode)">
            <summary>
            Moves the scheduling node next pointer to the next node.
            @TODO: need to assure that nothing is deleted out of m_nodes during this call
            </summary>
            <param name="node"> Scheduling node to start at when looking for the next node.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetFarthestSchedulingNode(System.Threading.ConcurrencyScheduler.SchedulingNode,System.Threading.ConcurrencyScheduler.SchedulingNode)">
            <summary>
            Looks backwards for a scheudling node
            </summary>
            <param name="owningNode"> Virtual processors owning node. </param>
            <param name="currentNode"> Node associated with virtual processors current ring. </param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNextSchedulingRing">
            <summary>
             Gets the next scheduling ring.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.SafeReference">
            <summary>
             Increments the reference count to the scheduler but does not allow a 0 to 1 transition.  This API should
             be used to safely access a scheduler when the scheduler is not 'owned' by the caller.
            </summary>
            <returns>true if the scheduler was referenced; false if the reference count was 0.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.DestroyExternalContext(System.Threading.ConcurrencyScheduler.ExternalContext,System.Boolean)">
            <summary>
            Removes context and scheduler related information from local storage. The context is ready to be
            cleaned up.
            </summary>
            <param name="context">The context to destroy.</param>
            <param name="explicitDetach">Whether this was a result of an explicit detach or the thread exiting.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.RescheduleContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Reschedules an internal context on a virtual processor, when returns from a nested scheduler. If a virtual
            processor is available, the context is assigned to it, if not, it is placed on the runnables collection
            in its schedule group.
            </summary>
            <param name="context"> The context to reschedule</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.StartupIdleVirtualProcessor(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Starts up an idle virtual processor to search for work, if one exists.
            </summary>
            <param name="group"> The group the virtual processor will start looking for work in.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.StartupAllIdleVirtualProcessors(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Starts up all idle virtual processor to search for work.
            </summary>
            <param name="group"> The group the virtual processor will start looking for work in.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.FindAvailableVirtualProcessor">
            <summary>
             Finds an available virtual processor in the scheduler, and returns it if one is available.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNewContextId">
            <summary>
             Returns a unique context id
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNewScheduleGroupId">
            <summary>
             Returns a unique schedule group id.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetNewVirtualProcessorId">
            <summary>
             Returns a unique virtual processor id.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetInternalContext">
            <summary>
             Acquires a new internal context of the appropriate type and returns it.  This can come from either
             a free list within the scheduler, the RM, or be one newly allocated from the heap.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ReleaseInternalContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
             Releases an internal context of the appropriate type to the scheduler.  The scheduler may decide to place
             this upon a free list, return it to RM, or free it.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.GetAnonymousScheduleGroup">
            <summary>
             References the anonymous schedule group, creating it if it doesn't exist, and returning it.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.WaitForWork">
            <summary>
             Called from InternalContext.Dispatch when no work can be found. Waits for work to arrive.
             
             @TODO: this currently uses a CLR monitor for synchronization, but still wakes up periodically
                 to synchronize properly with finalization.  Tighter event mechanisms are needed.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.NotifyRunnableIsAvailable">
            <summary>
            Notifies a waiting worker when a runnable is available to execute.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.NotifyWorkIsAvailable">
            <summary>
            When no work is available transitions to work is avaialable for any schedule group(runnable context or realized chore is added
            to a schedule group), NotifyWorkIsAvailable is called, which if called soon enough after WaitForWork will dispense with a kernel
            transition causing all active and executing dispatch contexts to search for work.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.WeaklyNotifyWorkIsAvailable">
            <summary>
            When no work is available transitions to work is avaialable for any schedule group(new chores are pushed onto workqueues),
            WeaklyNotifyWorkIsAvailable is called, which if called soon enough after WaitForWork will dispense with a kernel transition
            causing all active and executing dispatch contexts to search for work.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.VirtualProcessorActive(System.Boolean)">
            <summary>
             Called when a virtual processor becomes active (before it does) or becomes inactive (before it does).
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.FreezeActiveVProcCount">
            <summary>
             Freezes the count of virtual processors. After this point, until the count is unfrozen, no new virtual processor should
             become active, and no active virtual processors should de-activate.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.UnfreezeActiveVProcCount">
            <summary>
             Unfreezes the count of virtual processors when it was detected during shutdown that there was more work available.
             After this point, new virtual processor are allowed to become active/inactive.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.IncrementInternalContextCount">
            <summary>
             Internal contexts call this when created and used inside the scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.DecrementInternalContextCount">
            <summary>
             Internal contexts call this function in order to notify that they are out of dispatch.  The last internal context
             to call this will trigger scheduler finalization.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.SetDefaultScheduler(System.Threading.ConcurrencyScheduler.Scheduler,System.Threading.ConcurrencyScheduler.Scheduler)">
            <summary> Set the scheduler as the default if one doesn't already exist</summary>
            <param name="scheduler"> The scheduler to set as default.</param>
            <param name="overrideDefault"> A previous default that is in the process of being finalized. Set as default
            is allowed to override this value.</param>
            <returns> Returns if it was successful in setting the default scheduler </returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.RegisterForExitTracking(System.Threading.ConcurrencyScheduler.ExternalContext)">
            <summary>
            Thread handles for external contexts that are implicitly attached to the scheduler are used to track
            thread exit. A background thread (or threads) waits on a maximum of MAXIMUM_WAIT_OBJECTS -1 thread handles
            and responds to thread exit by releasing references on the scheduler and freeing other memory resources
            associated with the external contexts.
            </summary>
            <param name="context"> The external context whose handle is to be tracked.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ProcessContextExitEvents(System.Threading.ConcurrencyScheduler.ContextExitEventHandler)">
            <summary>
            Processes external context exit events for external contexts that get implicitly attached to schedulers.
            </summary>
            <param name="param"> A context exit event handler.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Shutdown">
            <summary>
             Called to initiate shutdown of the scheduler.  This may direclty proceed to phase two of shutdown (actively
             shutting down internal contexts) or it may wait for additional events (e.g.: all work to complete) before
             proceeding to phase two.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ReferenceForAttach">
            <summary>
             Increments the reference counts required by a scheduler attach.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.ReleaseForDetach">
            <summary>
             Decrements the reference counts incremented for scheduler attach.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.PhaseTwoShutdown">
            <summary>
             Actively informs all internal contexts to exit and breaks them out of their dispatch loops.  When the last
             internal context dies, finalization will occur and we move to Finalize().
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.FinalizeScheduler">
            <summary>
             Performs finalization of the scheduler deleting all structures, etc...  This will also notify any listeners
             that the scheduler has actively shut down.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.NotifyVirtualProcessorIdle">
            <summary>
             Internal contexts call the scheduler when they go idle for a specified amount of time in order to allow
             things that happen on scheduler idle to happen (e.g.: sweeping for phase two shutdown on WhenEmpty).
             
             This call *MUST* be made from a scheduler critical region.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.NotifyVirtualProcessorActive">
            <summary>
             Internal contexts call the scheduler when they transition out of idle before executing a work item or performing
             a context switch.  This may halt scheduler shutdown or it may coordinate with scheduler shutdown depending on
             the current phase of shutdown.
            
             This call *MUST* be made from a scheduler critical region.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.CheckInForSuspend">
            <summary>
             During the last stages of shutdown, the scheduler will inform all virtual processors that they must perform
             a check-in with the scheduler.  When all virtual processors check-in, the scheduler is suspended and final checks
             are made against finalization.  If all virtual processors perform this check-in, finalization completes.  If any
             go non-idle, finalization is halted and reset.  This call *WILL* block the caller and coordinate with scheduler
             shutdown in the final phases of shutdown.
            
             This call *MUST* be made from a scheduler critical region.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.FoundUnstartedChores">
            <summary>
            Called during scheduler finalization, after all virtual processors are suspended to check if any chores still
            exist in the scheduler. The calling thread is the only thread active in the scheduler at the time the function
            is called.
            </summary>
            <returns> A boolean value indicating whether any unstarted chores (realized or unrealized) were found.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.FoundBlockedContexts">
            <summary>
            Called during scheduler finalization, before all virtual processors are suspended to check if any blocked
            contexts exist in the scheduler.
            </summary>
            <returns> A boolean value indicating whether any blocked contexts were found.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.SweepSchedulerForFinalize">
            <summary>
             Once all virtual processors are idle, the scheduler calls this routine which performs a full sweep through all
             schedule groups looking for work.  If work is found (even a blocked context), the scheduler backs off finalization;
             otherwise, it proceeds by asking all virtual processors for final check-in.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Ressurrect">
            <summary>
             Called to perform a ressurrection of the scheduler.  When the scheduler reference count has fallen to zero
             on a WhenEmpty scheduler, it's possible there's still work on the scheduler and that one of those work items
             will perform an action leading to additional reference.  Such bringing of the reference count from zero
             to non-zero is only legal on an *INTERNAL* context and immediately halts shutdown.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.MarkVirtualProcessorsForSuspend(System.Boolean)">
            <summary>
             Marks all virtual processors within the scheduler as requiring suspension or clears the flag
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Scheduler.Initialize">
            <summary>
             Initialization.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Scheduler.CurrentScheduler">
            <summary>
             Returns the scheduler associated with the current context.  If there is no such scheduler, it will
             lazily associate the default scheduler with the current context.  The default scheduler may be lazily
             created by this accessor.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Scheduler.Id">
            <summary>
             A unique identifier for the scheduler
            </summary>
            <returns>A unique identifier for the scheduler</returns>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Scheduler.Policy">
            <summary>
             The scheduler policy utilized by the scheduler
            </summary>
            <returns>The scheduler policy utilized by the scheduler</returns>
        </member>
        <member name="E:System.Threading.ConcurrencyScheduler.Scheduler.SchedulerShutdown">
            <summary>
             An event which is fired immediately after the scheduler is shutdown and prior to finalization of the
             scheduler.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Scheduler.FastCurrentScheduler">
            <summary>
             Exposes the current scheduler without demand-init.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.Scheduler.DefaultScheduler">
            <summary>
             Get: Returns the default scheduler.  Creates one if it doesn't exist and tries to make it the default.
             NOTE: The API takes a reference on the scheduler which must be released by the caller appropriately.
            
             Set: Allows the user to set the process-wide default scheduler.  This is only allowed when there is no process-wide default.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.PolicyElementKey">
            <summary>
             <c>PolicyElementKey</c> enumerates all scheduler policy keys.
             Each policy can only have one value for each policy key.
             </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.SchedulerKind">
            <summary>
             Indicates the type of threads which the scheduler will utilize.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.MinHardwareThreads">
            <summary>
             Minimum number of hardware threads (e.g.: cores in core 2 arch) that must be
             provided by RM to run.  If there are more requested than exist, they policy is
             invalid.  If Min cannot be satisfied and WaitForResources==false, Scheduler.Create*
             will throw an exception.  When WaitForResources==true, Scheduler.Create* will block until
             the minimum resource request can be satisfied. On the other hand, Scheduler.Create* will
             create an instance with no vprocs assigned, so that work may be scheduled, but no tasks 
             will execute until RM CAS's in >= Min vprocs.
            
             The associated policy value is an int.
             The default value is 1.
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:System.Threading.ConcurrencyScheduler.PolicyElementKey.DesiredHardwareThreads" -->
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ResourceSharing">
            <summary>
             Specifies whether schedulers may share processing resources.  Exclusive indicates the scheduler
             has exclusive ownership of all hardware threads assigned to it by RM.  Sharable indicates that 2
             or more schedulers marked as such may time slice their work on hardware threads, with the OS 
             controlling time slicing.
            
             The associated policy value is a ResourceSharingType.
             The default value is ResourceSharingType.Sharable.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.WaitForResources">
            <summary>
             When Scheduler.Create* is called and RM cannot provide MinHardwareThreads, WaitForResources==true
             causes the Create call to block until RM can satisfy the minimum request.  When WaitForResources=false
             an RM cannot provide the minimum request, an exception is thrown.
            
             The associated policy value is a bool.
             The default value is false.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ThreadsMultiplier">
            <summary>
             Oversubscription multiplier.  If there are 4 hardware threads and the multiplier is 3, then 
             the scheduler will have 12 base vprocs.  The number of vprocs will increase beyond the base 
             as external contexts are attached or RM preemption management takes force to manage rogue chores.
            
             The associated policy value is an int.
             The default value is 1.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.LocalContextCacheSize">
            <summary>
             The maximum number of realized chores allowed in per-vproc context caching.
            
             The associated policy value is an int.
             The default value is 2.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ContextStackSize">
            <summary>
             The reserved stack size (in KB) of each context.
            
             The associated policy value is an int.
             The default value is 256.
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ResourcePriority" -->
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ContextPriority">
            <summary>
             The OS thread priority of each context in the scheduler.
            
             The associated policy value is a ThreadPriority.
             The default value is ThreadPriority.Normal
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.Fairness">
            <summary>
             Allows alternative scheduling algorithms to be specified.  Currently, EnhanceCacheLocality is the
             standard one, and EnhanceFairness is similar to CCR, where the current scheduler group is never
             searched first, but instead it starts at the round-robin-index in the associated scheduling
             ring.
            
             The associated policy value is a FairnessType.
             The default value is FairnessType.EnhanceCacheLocality.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.SchedulingNodeInertia">
            <summary>
             Specifies a spin delay before searching the next level of scheduling nodes (cf. SchedulingRings).
             Setting schedulingNodeInetria=10 indicates that the current scheduling node level must be searched
             without finding work 10 times in a row before going to the next level.
            
             The associated policy value is an int.
             The default value is 10.
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:System.Threading.ConcurrencyScheduler.PolicyElementKey.RogueChoreThreshold" -->
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.BackgroundRogueChoreMultiplier">
            <summary>
             Number of RogueChoreThreshold intervals before the priority of the rogue chore is lowered.
            
             The associated policy value is an int.
             The default value is SchedulerPolicy.Disabled
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.PollingInterval">
            <summary>
             Specifies the time interval in milliseconds that RM must delay before querying the scheduler's
             state.
            
             The associated policy value is an int.
             The default value is 5000.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.ShutdownCharacteristics">
            <summary>
             Shutdown indicates that a scheduler no longer referenced wil exit each internal context after
             the current task completes.  WhenEmpty indicates that a scheduler no longer referenced will exit
             each internal context when no work can be found.
            
             The associated policy value is a ShutdownCharacteristicsType.
             The default value is ShutdownCharacteristicsType.WhenEmpty.
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.IdleThreshold">
            <summary>
             When a scheduler experiences no work on all vprocs associated with a given hardware thread,
             for IdleThreshold seconds, then RM takes the hardware thread back as long as the # of hardware
             threads is >= minimum.  However, when all vprocs experience no work for IdleThreshold seconds,
             RM takes back all hardware threads.
            
             The associated policy value is an int.
             The default value is SchedulerPolicy.Disabled
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.UseHyperThreads">
            <summary>
             When true allows hyperthreads to be hardware threads.
            
             The associated policy value is a bool.
             The default value is true
            
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PolicyElementKey.InheritThreadPriority">
            <summary>
             When true, the internal contexts priority is inherited from the priority of the thread creating the scheduler.
            
             The associated policy value is a bool
             The default value is false
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerType">
            <summary>
             Indicates the type of threads a scheduler will utilize
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerType.DefaultScheduler">
            <summary>
             Indicates that the runtime is responsible for choosing the appropriate type based on the underlying system.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:System.Threading.ConcurrencyScheduler.SchedulerType.ThreadScheduler" -->
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerType.UmsThreadScheduler">
            <summary>
             UMS Threads.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.FairnessType">
            <summary>
             Indicates the scheduling protocol
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.FairnessType.EnhanceCacheLocality">
            <summary>
             Implies unblocked contexts are scheduled LIFO and per-vproc local runnable caching of unblocked contexts is
             enabled.  Moreover, the current task group is searched for work before searching other task groups based on a
             round-robin index that points to the 'next' task group after where work was found last.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.FairnessType.EnhanceFairness">
            <summary>
             Implies unblocked contexts are scheduled FIFO and per-vproc local runnable caching of unblocked contexts is
             disabled.  Searching for work begins at the task group pointed to by the round-robin index that points
             to the 'next' task group after where work was found last.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.PriorityType">
            <summary>
             Resource allocation priority.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PriorityType.LowestPriority">
            <summary>
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PriorityType.BelowNormalPriority">
            <summary>
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PriorityType.NormalPriority">
            <summary>
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PriorityType.AboveNormalPriority">
            <summary>
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.PriorityType.HighestPriority">
            <summary>
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ResourceSharingType">
            <summary>
             Indicates whether a scheduler is allowed exclusive ownership of hardware threads.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ResourceSharingType.Exclusive">
            <summary>
             Indicates that the scheduler has exclusive ownership of hardware threads.  Note that this policy
             at present is disabled and behaves exactly as shared.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ResourceSharingType.Sharable">
            <summary>
             Indicates that two or more schedulers may share the underlying hardware thread and have work
             time sliced by the underlying OS.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.ShutdownCharacteristicsType">
            <summary>
             Indicates how the scheduler will shut down.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ShutdownCharacteristicsType.Shutdown">
            <summary>
             Indicates that upon reaching zero reference count, the scheduler will shutdown after current contexts
             finish executing their corresponding chore.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.ShutdownCharacteristicsType.WhenEmpty">
            <summary>
             Indicates that upon reaching zero reference count, the scheduler will shutdown after all work upon
             the scheduler has completed.  Note that it is possible that if current work schedules more work,
             such a scheduler will never shutdown.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement">
            <summary>
             A key/value pair for a specified policy element
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement.#ctor(System.Threading.ConcurrencyScheduler.PolicyElementKey,System.Object)">
            <summary>
             Constructs a new key/value pair.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement.m_key">
            <summary>
             The key.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement.m_value">
            <summary>
             The value.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement.Key">
            <summary>
             The key.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerPolicyElement.Value">
            <summary>
             The value.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulerPolicy">
            <summary>
             A policy which defines the behaviors and characteristics of a scheduler.
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerPolicy.MaxHardwareThreads">
            A special value indicating that the scheduler should attempt to utilize all hardware threads available
            on the underlying system.
            Magic value -- (TBD -- fix it up so that MaxHardwareThreads/2 makes sense)
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerPolicy.Disabled">
            A special value indicating that a policy should be disabled.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.#ctor(System.Threading.ConcurrencyScheduler.SchedulerPolicy)">
            <summary>
             Copies a scheduler policy.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.#ctor(System.Threading.ConcurrencyScheduler.SchedulerPolicyElement[])">
            <summary>
             Constructs a new scheduler policy based on a set of key/value pairs.
            </summary>
            <param name="policyElements">The set of key/value pairs describing the policy</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.IsCompliantWith(System.Threading.ConcurrencyScheduler.SchedulerPolicy)">
            <summary>
             Determines whether 'this' is compatible with 'required'.  This may allow code to avoid creating
             a new scheduler if the current scheduler already meets the requirements.  A more declarative
             style of scheduler allocation may also be built from the ability to test scheduler compliance.
            </summary>
            <remarks>
             The schedulers are only compared against policy values explicitly set in 'required'.  Any which
             are left at default values are treated as don't care with respect to the comparison.
            </remarks>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.#ctor(System.Object[])">
            <summary>
             Constructs a scheduler policy from a fully specified array of policy values
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.GetMaxPolicyElementKey">
            <summary>
             Returns the largest PolicyElementKey value
            </summary>
            <remarks>
             This value may need to change if policy elements are added
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Threading.ConcurrencyScheduler.SchedulerPolicy.ValidatePolicyValue(System.Threading.ConcurrencyScheduler.PolicyElementKey,System.Object)" -->
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulerPolicy.s_globalPolicyDefaults">
            The default scheduler policy
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerPolicy.IsValid">
            <summary>
             An indication of whether the policy is valid or not.
            </summary>
            <returns>An indication of whether the policy is valid or not.</returns>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.SchedulerPolicy.Item(System.Threading.ConcurrencyScheduler.PolicyElementKey)">
            <summary>
             Indexes policy elements within the policy by key, providing get/set accessors for a particular policy value
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.RMTaskState">
            running task state
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.RMProcessorNode">
            description of a processor package or NUMA node
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.RMTaskStateEx">
            hook to query state
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.GetPolicyValues(System.Int32[]@,System.Int32,System.Int32@)">
            The following keys need to be supported:
                "MinHardwareThreads"
                "DesiredHardwareThreads"
                "ResourceSharing"
                "WaitForResources"
                "ResourcePriority"  
                "RogueChoreThreshold"
                "BackgroundRogueChoreMultiplier"
                "PollingInterval"
                "IdleThreshold"
            Return scheduler policy values for valid keys.  Error states E_INVALID_POLICY and E_BAD_INPUT.    
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.SetSchedulerId(System.Int32)">
            Set a new scheduler’s id.  No error state.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.WorkloadPressure(System.Double@)">
            Returns the workload pressure metric which is roughly defined as the rate of change
            of the growth of all runnables and workqueues.  Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.ExecutingTasks(System.Threading.ConcurrencyScheduler.RMTaskState@,System.Int32,System.Int32@)">
            Returns the ids of currently executing tasks and contexts.  It is imprecise to avoid    
            synchronization.  False return indicates an error -- for example ‘count’ is not big 
            enough (E_BAD_COUNT).  Information is used for PreemptTask/RudelyPreemptTask.
            If resetForBlock is true, the time count for rogue chore determination starts over.  
            Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.AddHardwareThreads(System.Int16@,System.Byte@,System.Int32)">
            Add hardware threads to a scheduler.  RM hands the scheduler some hardware 
            threads identified by a processor group number and a bitmask.  This API supports >
            64 cores.  Parameters are in.  Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.RemoveHardwareThreads(System.Int16@,System.Byte@,System.Int32)">
            Request that a scheduler remove some hardware threads.  The scheduler will call 
            back when done (cf. IResourceManagement.HardwareThreadsRemoved) RM initiates 
            the protocol for taking some hardware threads identified by 
            a processor group number and a bitmask away from the scheduler.  This API 
            supports > 64 cores.  Parameters are in.  Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.PreemptTask(System.Threading.ConcurrencyScheduler.RMTaskState@)">
            Causes scheduler to assign another vproc to the hardware thread.
            This API supports > 64 cores.  Parameter is in.  Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.ForcePreemptTask(System.Threading.ConcurrencyScheduler.RMTaskState@)">
            Assumes Preempt task has already been called.  This method will lower the priority 
            of a rogue task. Parameter is in.  Error state E_BAD_INPUT.
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ISchedulerResourceManagement.GetToplogy(System.Threading.ConcurrencyScheduler.RMProcessorNode@,System.Int32,System.Int32@,System.Threading.ConcurrencyScheduler.RMTaskStateEx@,System.Int32,System.Int32@)">
            Identifies the hardware (and software for newer OSes) mapping of nodes to hardware 
            threads for this scheduler.  When called with nodes=NULL, sets *pCount to the 
            number of nodes active.  Error state E_BAD_INPUT.
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.SchedulingNode">
            <summary>
            A scheduling node corresponds to a NUMA node or a processor package; containing one or more virtual processor groups.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingNode.CheckForNewOwningRing">
            <summary>
            When all vprocs are rambling (searching foreign nodes for work), find the ring with the most vprocs working on it and set that to
            the owning ring for all vprocs.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.#ctor(System.Threading.ConcurrencyScheduler.Scheduler)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.AllocateScheduleGroup">
            <summary>
            Allocates a new schedule group depending on the fairness policy.
            </summary>
            <returns> A newly allocated schedule group</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.CreateScheduleGroup">
            <summary>
            Create a schedule group, add it to the list of groups
            </summary>
            <returns> A newly created schedule group</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.AssignScheduleGroup(System.Threading.ConcurrencyScheduler.Context)">
            <summary>
            Pick a schedule group from the scheduler to assign a context
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.RemoveScheduleGroup(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Called when the reference count of a schedule group goes to 0. Removes the schedule group from the ring
            </summary>
            <param name="group">The schedule group to remove</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.SearchForRunnableContext(System.Threading.ConcurrencyScheduler.FairnessType,System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Searches for a runnable context in the ring.
            </summary>
            <param name="fairnessType"> The fairness policy type. Tells whether to ignore the current group while searching.</param>
            <param name="currentGroup"> The current schedule group of the context searching for a runnable.</param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.SearchForRealizedChore(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
             Finds a realized chore for the context to execute.
             Searches for a realized chore in the schedule group pointed to by m_pNextGroup, followed by all other schedule groups in
             the node.  If a chore is found, then m_pGroup is
             modified to reflect that, as well as m_pNextGroup.
             Do not search currentGroup or context.m_currentGroup
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.SearchForAnyRealizedChore(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
             Finds a realized chore for the context to execute.
             Searches for a realized chore in the schedule group pointed to by m_pNextGroup, followed by all other schedule groups in
             the node.  If a chore is found, then m_pGroup is
             modified to reflect that, as well as m_pNextGroup.
             Searches all schedule groups.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.SearchForAnyRealizedContext">
            <summary>
            Searches for a realized chore and converts it into a context
            </summary>
            <returns> An internal context that is associated with the realized chore found</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.SearchForRealized(System.Threading.ConcurrencyScheduler.FairnessType,System.Threading.ConcurrencyScheduler.ScheduleGroup,System.Threading.ConcurrencyScheduler.ScheduleGroup@)">
            <summary>
            Searches for an realized chore in the scheduling ring.
            </summary>
            <param name="fairnessType"> The fairness policy type</param>
            <param name="currentGroup"> Current group </param>
            <param name="newGroup"> The group in which the chore is found.</param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.StealUnrealizedChore(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
             Finds a stolen chore for the context to execute.
             Searches for a stolen chore in the schedule group pointed to by m_pNextGroup, followed by all other schedule groups in
             the node.  If a chore is found, then m_pGroup is
             modified to reflect that, as well as m_pNextGroup.
             Do not search currentGroup or context.m_currentGroup
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.StealUnrealizedContext(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Steals an unrealized chore ignoring the current group and associates it with a context.
            </summary>
            <param name="currentGroup"> Current schedule group</param>
            <returns> An internal context associated with the unrealized chore that was stolen.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.StealAnyUnrealizedChore(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
             Finds a stolen chore for the context to execute.
             Searches for a stolen chore in the schedule group pointed to by m_pNextGroup, followed by all other schedule groups in
             the node.  If a chore is found, then m_pGroup is
             modified to reflect that, as well as m_pNextGroup.
             Searches all schedule groups.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.StealAnyUnrealizedContext">
            <summary>
            Steals an unrealized chore and associates it with a context.
            </summary>
            <returns> An internal context associated with the unrealized chore that was stolen.</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.StealUnrealized(System.Threading.ConcurrencyScheduler.FairnessType,System.Threading.ConcurrencyScheduler.ScheduleGroup,System.Threading.ConcurrencyScheduler.ScheduleGroup@)">
            <summary>
            Steal task.
            </summary>
            <param name="currentGroup"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.ReleaseInternalContext(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Puts an internal context back into the pool of free contexts
            </summary>
            <param name="context"> An idle internal context.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.SchedulingRing.GetInternalContext(System.Threading.ConcurrencyScheduler.ScheduleGroup,System.Threading.Tasks.TaskBase,System.Boolean)">
            <summary>
            Gets an idle context from the idle context pool and associates it with a realized chore.
            All contexts on the context pool should be InternalContext
            </summary>
            <param name="group"> The group with which the context is to be associated</param>
            <param name="chore"> A chore to associated with the context </param>
            <param name="choreStolen"> Valid only when chore is non-null. Specifies whether the chore was stolen</param>
            <returns></returns>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulingRing.m_nextGroup">
            <summary>
            round-robin index
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulingRing.m_scheduler">
            <summary>
            owning scheduler
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.SchedulingRing.m_scheduleGroups">
            <summary>
            schedule groups groups owned by this node
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskTypes">
            <summary>
             Indicates the type of a task (how it was scheduled).
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskTypes.None">
            <summary>
            No flags are set.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskTypes.StructuredParallel">
            <summary>
            Structured parallel tasks are those where any spawned child is guaranteed to complete by the time the 
            parent task completes.  They exhibit a fork-join style of parallelism.  The ConcRT parallel {} construct, 
            the ConcRT parallel for construct, the TPL Parallel.Do() construct, and the TPL Parallel.For construct 
            are examples of this type of structured parallelism.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskTypes.UnstructuredParallel">
            <summary>
            Unstructured parallel tasks are those where the lifetime of any spawned child is unrelated to the lifetime 
            of the task which spawned it.  While they may be utilized in some capacities to perform fork-join 
            parallelism, the construct’s structure does not guarantee such. ConcRT’s finish { begin } construct 
            and arbitrary TPL tasks and futures are examples of this type of unstructured parallelism.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskTypes.NonWorkStealing">
            <summary>
            Non work stealing tasks are those which are not placed on a work stealing queue.  
            ConcRT’s agent tasks and CCR tasks are examples of this type of task.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskState">
            <summary>
             Keeps track of the internal state of a task to allow resolution of TryPop/Steal interleavings 
             within a work stealing queue.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskState.NotStarted">
            <summary>
            Indicates that the work has not been started.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskState.Started">
            <summary>
            Indicates that work has been started.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadExternalContext.Suspend">
            <summary>
            Causes the external context to stop running - since there is no underlying virtual processor in the 
            case of an external context, the context simply waits until it is unblocked.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadExternalContext.Resume">
            <summary>
            Causes the external context to start running - since it does not have to wait for a virtual processor
            to execute it, it starts running immediately.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ThreadExternalContext.ContextKind">
            <summary>
            Returns the type of context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadInternalContext.SwitchOut(System.Threading.ConcurrencyScheduler.InternalContext.ReasonForSwitch)">
            <summary>
            Switches out the internal context. Useful, when the virtual processor is to be retired.
            Is also used when un-nesting a scheduler and the context is returning to its original scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadInternalContext.ExecuteContext">
            <summary>
            Called by an idle virtual processor to execute this internal thread context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadInternalContext.BlockUntilDispatched">
            <summary>
            Blocks the internal thread context right after creation, so that it starts running its 
            dispatch loop only when selected by the scheduler to run.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadInternalContext.LeaveScheduler">
            <summary>
            Called when a context is nesting a scheduler. If nesting takes place on what is an internal context in
            the 'parent' scheduler, the context must return the virtual processor to the parent scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadInternalContext.RejoinScheduler">
            <summary>
            Called when a context is un-nesting a scheduler. If the parent context is an internal context, it needs
            to rejoin the parent scheduler by looking for a virtual processor it can execute on.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.ThreadInternalContext.ContextKind">
            <summary>
            Returns the type of context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadScheduler.CreateVirtualProcessor(System.Threading.ConcurrencyScheduler.SchedulingNode,System.Threading.ConcurrencyScheduler.VirtualProcessorGroup)">
            <summary>
             Creates a virtual processor of the appropriate type for this scheduler and returns it.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadScheduler.CreateInternalContext">
            <summary>
             Creates an internal context of the appropriate type for this scheduler and returns it.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadScheduler.CreateExternalContext(System.Boolean)">
            <summary>
             Converts threads into external contexts.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.Suspend(System.Boolean)">
            <summary>
             Marks the virtual processor for suspend or clears the flag.  A marked virtual processor will check
             in with the scheduler at the next IDLE.
            </summary>
            <param name="suspend">Whether to set or clear the suspend flag</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.Execute(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Starts up the virtual process with the context provided. @TOD0 -- put in threadVP
            </summary>
            <param name="context"> The context to execute on this virtual processor.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.Restart(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Restarts a virtual processor when an internal context joins a nested scheduler temporarily.
            </summary>
            <param name="currentGroup">The schedule group the internal context was working on.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.Affinitize(System.Threading.ConcurrencyScheduler.InternalContext,System.Boolean)">
            <summary>
            Affinitizes an internal context to the virtual processor.
            </summary>
            <param name="context"> The internal context to affinitize.</param>
            <param name="currentlyRunning"> Specifies whether the context is running. This argument is true when a internal context
            is returning from a nested scheduler, and an available vproc is found to assign to it immediately.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.StartupWorkerContext(System.Threading.ConcurrencyScheduler.ScheduleGroup)">
            <summary>
            Start a worker context executing on this virtual processor.
            </summary>
            <param name="group"> Group that the internal context will start out searching for work.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.StealLocalRunnableContext">
            <summary>
            Steals an internal contexts from the local runnables workstealing queue of other virtual processors
            in the node.
            </summary>
            <returns> Stolen internal context</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessor.GetLocalRunnableContext">
            <summary>
            Tries to pop a local runnable context off the workstealing queue.
            </summary>
            <returns> Local runnable context</returns>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_owningNode">
            owning scheduling node
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_currentNode">
            current scheduling node
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_owningGroup">
            owning virtual processor group -- should be hashtable lookup because it is infrequent
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_suspend">
            Flag specifying whether this is a temporary virtual processor.
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_available">
            indicates whether vproc has been associated with a hardware thread
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessor.m_id">
            unique identifier for vprocs within a scheduler
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.VirtualProcessor.Id">
            <summary>
            Unique identifier for virtual processors within the scheduler.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.ThreadVirtualProcessor.#ctor(System.Threading.ConcurrencyScheduler.SchedulingNode,System.Threading.ConcurrencyScheduler.VirtualProcessorGroup)">
            <summary>
             @TODO:
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Tracing.EnableTracing">
            <summary>
            Enable tracing
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Tracing.DisableTracing">
            <summary>
            Disable tracing
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Tracing.ShouldTrace(System.Byte)">
            <summary>
            ShouldTrace indicates whether tracing is enabled for a particular level.
            </summary>
            <param name="level">Trace level</param>
            <returns>true if tracing is enabled</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Tracing.TraceEvent(System.Threading.ConcurrencyScheduler.Tracing.CONCRT_TRACE_EVENT_HEADER_COMMON)">
            <summary>
            Trace an event
            </summary>
            <param name="tracePacket">The content of the event</param>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ConcRT_ProviderGuid">
            <summary>Managed ConcRT provider GUID:  {7B6F73A3-EE8D-4559-91DE-A98D0C63492A}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ConcRTEventGuid">
            <summary>ConcRTEventGuid:  {72B14A7D-704C-423e-92F8-7E6D64BCB92A}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.SchedulerEventGuid">
            <summary>SchedulerEventGuid:  {E2091F8A-1E0A-4731-84A2-0DD57C8A5261}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ScheduleGroupEventGuid">
            <summary>ScheduleGroupEventGuid:  {E8A3BF1F-A86B-4390-9C60-5390B969D22C}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ContextEventGuid">
            <summary>ContextEventGuid:  {5727A00F-50BE-4519-8256-F7699871FECB}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ChoreEventGuid">
            <summary>ChoreEventGuid:  {7E854EC7-CDC4-405a-B5B2-AAF7C9E7D40C}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.LockEventGuid">
            <summary>LockEventGuid:  {79A60DC6-5FC8-4952-A41C-1163AEEC5EB8}</summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.Tracing.ResourceManagerEventGuid">
            <summary>ResourceManagerEventGuid:  {2718D25B-5BF5-4479-8E88-BABC64BDBFCA}</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.Tracing.ControlCallback(System.Threading.ConcurrencyScheduler.NativeMethods.WMIDPREQUESTCODE,System.IntPtr,System.UInt32*,System.IntPtr)">
            <summary>
            Callback Method that is used to check whether the controller has enabled the provider to send trace or not.
            if controller (such as logman) does not start a session then ETW events are not sent. This method is called
            by OS when required
            </summary>
            <param name="RequestCode"></param>
            <param name="Context"></param>
            <param name="InOutBufferSize"></param>
            <param name="Buffer"></param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.Tracing.CONCRT_TRACE_EVENT_HEADER_COMMON">
            <summary>The common concrt ETW header.</summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.Tracing.EVENT_TRACE_HEADER">
            <summary>
            Header of the ETW trace packet. simplified structure (from the original struct definitions) is used.
            Omitted alternate union-fields which are not used.
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.Tracing.ConcRT_EventType">
            <summary>ConcRT event types</summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NativeMethods.GetHRFromWin32(System.UInt32)">
            <summary>
            Method that converts the return code into error message (if the code is an error). any code returned other than zero is an error
            </summary>
            <param name="dwErr"></param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.NativeMethods.TRACE_GUID_REGISTRATION">
            <summary>
            This is a dummy struct we need for storing the Registration guid info (to prevent XP from throwing error)
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WorkStealingWrapper`1">
            <summary>
            A value class wrapper around the polymorphic type TaskBase. 
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1">
            <summary>
            A WorkStealingQueue is a wait-free, lock-free structure associated with a single
            thread that can Push and Pop elements. Other threads can do Steal operations
            on the other end of the WorkStealingQueue with little contention.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs a new work stealing queue
            </summary>
            <param name="allowOutOfOrder">Indicates whether or not the work stealing queue will allow 
            out of order waiting on the bound thread.  Allowing this has additional cost.</param>
            <param name="initialSize">Indicates the initially allocated size for the physical work item storage</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.#ctor">
            <summary>
            Constructs a new work stealing queue
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.Steal">
            <summary>
            Attempts to steal the oldest element in the queue.  This handles potential interleaving with both
            a Pop and TryPop operation.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.Pop">
            <summary>
            Attempts to pop the newest element on the work stealing queue.  It may return NULL if there is no such
            item (either unbalanced push/pop, a chore stolen)
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.Push(`0)">
            <summary>
            Pushes an element onto the work stealing queue.  
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.SyncPop">
            <summary>
            Synchronously pops an element from the work stealing queue.  Note that this is called in the case where
            a Pop() call and a Steal() call interleave.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.SyncPush(`0)">
            <summary>
            Pushes an element onto the work stealing queue under the queue lock.  This guarantees that no steal
            interleaves and guarantees the ability to reallocate the physical store. 
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.StructuredWorkStealingQueue`1.Count">
            <summary>
            unlocked count
            </summary>
            <returns>count</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NativeHandle.#ctor">
            <summary>
            NativeHandle constructor
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.NativeHandle.ReleaseHandle">
            <summary>
            Release Handle
            </summary>
            <returns>A bool indicating whether or not the handle was released</returns>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.NativeHandle.UnderlyingHandle">
            <summary>
            Access for the underlying thread handle
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessorGroup.#ctor(System.UInt16,System.Byte)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.VirtualProcessorGroup.Affinitize(System.Threading.ConcurrencyScheduler.InternalContext)">
            <summary>
            Affinitizes the context to the hardware thread this group represents
            </summary>
            <param name="context"> The internal context to affinitize</param>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessorGroup.m_virtualProcessors">
            <summary>
            virtual processors owned by this group
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessorGroup.m_processorGroup">
            <summary>
            processor group number for > 64 proc support
            </summary>
        </member>
        <member name="F:System.Threading.ConcurrencyScheduler.VirtualProcessorGroup.m_idealProcessor">
            <summary>
            physical ideal processor 
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WorkQueue">
            <summary>
            The work queue is a pair of bound work stealing queues, one structured and one unstructured, that
            can be associated with a context.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.#ctor">
            <summary>
            Constructs a new work queue.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.PushStructured(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes a new structured task upon the work stealing queue.
            </summary>
            <param name="task">The task to push onto the structured work stealing queue</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.PopStructured">
            <summary>
            Pops a structured task from the work stealing queue.
            </summary>
            <returns>The topmost structured task or null if no such task exists</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.PushUnstructured(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes an unstructured task upon the work stealing queue.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.TryPopUnstructured(System.Threading.Tasks.TaskBase)">
            <summary>
            Attempts to pop the specified task from the unstructured work stealing queue.  Failure to
            pop indicates that the task is not in the work stealing queue (it either was never there
            or it was already stolen).
            </summary>
            <returns>An indication of whether the attempt to pop succeeded</returns>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkQueue.Steal">
            <summary>
            Steal a chore from the work stealing queue for unstructured parallelism.
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.WorkQueue.IsStructuredEmpty">
            <summary>
            Returns whether or not the structured work stealing queue is empty.  Note that this should only be called when detached
            from a context (or being detached).
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.WorkQueue.IsUnstructuredEmpty">
            <summary>
            Returns whether or not the unstructured work stealing queue is empty.  Note that this should only be called when detached
            from a context (or being detached).
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.TaskBaseWrapper">
            <summary>
            A value class wrapper around the polymorphic type TaskBase. 
            </summary>
        </member>
        <member name="T:System.Threading.ConcurrencyScheduler.WorkStealingQueue">
            <summary>
            A WorkStealingQueue is a wait-free, lock-free structure associated with a single
            thread that can Push and Pop elements. Other threads can do Steal operations
            on the other end of the WorkStealingQueue with little contention.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.#ctor(System.Boolean,System.Int32)">
            <summary>
            Constructs a new work stealing queue
            </summary>
            <param name="allowOutOfOrder">Indicates whether or not the work stealing queue will allow 
            out of order waiting on the bound thread.  Allowing this has additional cost.</param>
            <param name="initialSize">Indicates the initially allocated size for the physical work item storage</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.#ctor(System.Boolean)">
            <summary>
            Constructs a new work stealing queue
            </summary>
            <param name="allowOutOfOrder">Indicates whether or not the work stealing queue will allow 
            out of order waiting on the bound thread.  Allowing this has additional cost.</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.#ctor">
            <summary>
            Constructs a new work stealing queue
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.Steal">
            <summary>
            Attempts to steal the oldest element in the queue.  This handles potential interleaving with both
            a Pop and TryPop operation.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.TryPop(System.Threading.Tasks.TaskBase)">
            <summary>
            Tries to pop a previously pushed element from the work stealing queue.  Note that this executes
            a potentially out-of-order wait.
            </summary>
            <param name="task">The task to attempt to pop</param>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.Pop">
            <summary>
            Attempts to pop the newest element on the work stealing queue.  It may return NULL if there is no such
            item (either unbalanced push/pop, a chore stolen)
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.Push(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes an element onto the work stealing queue.  
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.SyncPop">
            <summary>
            Synchronously pops an element from the work stealing queue.  Note that this is called in the case where
            a Pop() call and a Steal() call interleave.
            </summary>
        </member>
        <member name="M:System.Threading.ConcurrencyScheduler.WorkStealingQueue.SyncPush(System.Threading.Tasks.TaskBase)">
            <summary>
            Pushes an element onto the work stealing queue under the queue lock.  This guarantees that no steal
            interleaves and guarantees the ability to reallocate the physical store. 
            </summary>
        </member>
        <member name="P:System.Threading.ConcurrencyScheduler.WorkStealingQueue.Count">
            <summary>
            Returns the count of items in the work stealing queue (unlocked).
            </summary>
        </member>
        <member name="M:System.Threading.Internal.PFXSRDescriptionAttribute.#ctor(System.String)">
            <summary>
                Constructs a new sys description.
            </summary>
            <param name='description'>
                description text.
            </param>
        </member>
        <member name="P:System.Threading.Internal.PFXSRDescriptionAttribute.Description">
            <summary>
                Retrieves the description text.
            </summary>
            <returns>
                description
            </returns>
        </member>
        <member name="T:System.Threading.Internal.PFXSR">
             <summary>
                AutoGenerated resource class. Usage:
            
                    string s = PFXSR.GetString(PFXSR.MyIdenfitier);
             </summary>
        </member>
    </members>
</doc>
